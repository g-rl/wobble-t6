// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_vehicle;
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;

main()
{
    type = "qrdrone_mp";
    registerclientfield( "helicopter", "qrdrone_state", 1, 3, "int", ::statechange, 0 );
    level._effect["qrdrone_enemy_light"] = loadfx( "weapon/qr_drone/fx_qr_light_red_3p" );
    level._effect["qrdrone_friendly_light"] = loadfx( "weapon/qr_drone/fx_qr_light_green_3p" );
    level._effect["qrdrone_viewmodel_light"] = loadfx( "weapon/qr_drone/fx_qr_light_green_1p" );
}

spawned( localclientnum )
{
    self waittill_dobj( localclientnum );
    self thread qrdronefx( localclientnum, 0 );
    self thread collisionhandler( localclientnum );
    self thread enginestutterhandler( localclientnum );
    self thread qrdrone_watch_distance();
}

statechange( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "entityshutdown" );
    self qrdronefx( localclientnum, newval );
}

qrdronefx( localclientnum, blinkstage )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );
    waittillsnapprocessed( localclientnum );
    fx_handle = self restartfx( localclientnum, blinkstage );

    if ( isdefined( fx_handle ) )
    {
        self notify( "teamBased_fx_reinitialized" );
        level thread watchforplayerrespawnforteambasedfx( localclientnum, self, ::qrdronefx, fx_handle, blinkstage );
    }
}

restartfx( localclientnum, blinkstage )
{
    self notify( "restart_fx" );
/#
    println( "Restart QRDrone FX: stage " + blinkstage );
#/
    fx_handle = undefined;

    switch ( blinkstage )
    {
        case 0:
            fx_handle = self spawn_solid_fx( localclientnum );
            break;
        case 1:
            self.fx_interval = 1.0;
            self spawn_blinking_fx( localclientnum );
            break;
        case 2:
            self.fx_interval = 0.133;
            self spawn_blinking_fx( localclientnum );
            break;
        case 3:
            self notify( "stopfx" );
            self notify( "fx_death" );
            return;
    }

    self thread watchrestartfx( localclientnum );
    return fx_handle;
}

watchrestartfx( localclientnum )
{
    self endon( "entityshutdown" );
    level waittill_any( "demo_jump", "player_switch", "killcam_begin", "killcam_end" );
    self qrdronefx( localclientnum, getclientfield( "qrdrone_state" ) );
}

spawn_solid_fx( localclientnum )
{
    if ( self islocalclientdriver( localclientnum ) )
        fx_handle = playfxontag( localclientnum, level._effect["qrdrone_viewmodel_light"], self, "tag_body" );
    else if ( self friendnotfoe( localclientnum ) )
        fx_handle = playfxontag( localclientnum, level._effect["qrdrone_friendly_light"], self, "tag_body" );
    else
        fx_handle = playfxontag( localclientnum, level._effect["qrdrone_enemy_light"], self, "tag_body" );

    self thread cleanupfx( localclientnum, fx_handle );
    return fx_handle;
}

spawn_blinking_fx( localclientnum )
{
    self thread blink_fx_and_sound( localclientnum, "wpn_crossbow_alert" );
}

blink_fx_and_sound( localclientnum, soundalias )
{
    self endon( "entityshutdown" );
    self endon( "restart_fx" );
    self endon( "fx_death" );

    if ( !isdefined( self.interval ) )
        self.interval = 1.0;

    while ( true )
    {
        self playsound( localclientnum, soundalias );
        self spawn_solid_fx( localclientnum );
        serverwait( localclientnum, self.interval / 2 );
        self notify( "stopfx" );
        serverwait( localclientnum, self.interval / 2 );
        self.interval = self.interval / 1.17;

        if ( self.interval < 0.1 )
            self.interval = 0.1;
    }
}

cleanupfx( localclientnum, handle )
{
    self waittill_any( "entityshutdown", "blink", "stopfx", "restart_fx" );
    stopfx( localclientnum, handle );
}

start_blink( localclientnum, set )
{
    if ( !set )
        return;

    self notify( "blink" );
}

final_blink( localclientnum, set )
{
    if ( !set )
        return;

    self.interval = 0.133;
}

loop_local_sound( localclientnum, alias, interval, fx )
{
    self endon( "entityshutdown" );
    self endon( "stopfx" );
    level endon( "demo_jump" );
    level endon( "player_switch" );

    if ( !isdefined( self.interval ) )
        self.interval = interval;

    while ( true )
    {
        self playsound( localclientnum, alias );
        self spawn_solid_fx( localclientnum );
        serverwait( localclientnum, self.interval / 2 );
        self notify( "stopfx" );
        serverwait( localclientnum, self.interval / 2 );
        self.interval = self.interval / 1.17;

        if ( self.interval < 0.1 )
            self.interval = 0.1;
    }
}

check_for_player_switch_or_time_jump( localclientnum )
{
    self endon( "entityshutdown" );
    level waittill_any( "demo_jump", "player_switch", "killcam_begin" );
    self notify( "stopfx" );
    waittillframeend;
    self thread blink_light( localclientnum );

    if ( isdefined( self.blinkstarttime ) && self.blinkstarttime <= level.servertime )
    {
        self.interval = 1;
        self thread start_blink( localclientnum, 1 );
    }
    else
        self thread qrdronefx( localclientnum, 0 );

    self thread check_for_player_switch_or_time_jump( localclientnum );
}

blink_light( localclientnum )
{
    self endon( "entityshutdown" );
    level endon( "demo_jump" );
    level endon( "player_switch" );
    level endon( "killcam_begin" );
    self waittill( "blink" );

    if ( !isdefined( self.blinkstarttime ) )
        self.blinkstarttime = level.servertime;

    if ( self islocalclientdriver( localclientnum ) )
        self thread loop_local_sound( localclientnum, "wpn_crossbow_alert", 1, level._effect["qrdrone_viewmodel_light"] );
    else if ( self friendnotfoe( localclientnum ) )
        self thread loop_local_sound( localclientnum, "wpn_crossbow_alert", 1, level._effect["qrdrone_friendly_light"] );
    else
        self thread loop_local_sound( localclientnum, "wpn_crossbow_alert", 1, level._effect["qrdrone_enemy_light"] );
}

collisionhandler( localclientnum )
{
    self endon( "entityshutdown" );

    while ( true )
    {
        self waittill( "veh_collision", hip, hitn, hit_intensity );
        driver_local_client = self getlocalclientdriver();

        if ( isdefined( driver_local_client ) )
        {
            player = getlocalplayer( driver_local_client );

            if ( isdefined( player ) )
            {
                if ( hit_intensity > 15 )
                    player playrumbleonentity( driver_local_client, "damage_heavy" );
                else
                    player playrumbleonentity( driver_local_client, "damage_light" );
            }
        }
    }
}

enginestutterhandler( localclientnum )
{
    self endon( "entityshutdown" );

    while ( true )
    {
        self waittill( "veh_engine_stutter" );

        if ( self islocalclientdriver( localclientnum ) )
        {
            player = getlocalplayer( localclientnum );

            if ( isdefined( player ) )
                player playrumbleonentity( localclientnum, "rcbomb_engine_stutter" );
        }
    }
}

getminimumflyheight()
{
    if ( !isdefined( level.airsupportheightscale ) )
        level.airsupportheightscale = 1;

    airsupport_height = getstruct( "air_support_height", "targetname" );

    if ( isdefined( airsupport_height ) )
        planeflyheight = airsupport_height.origin[2];
    else
    {
/#
        println( "WARNING:  Missing air_support_height entity in the map.  Using default height." );
#/
        planeflyheight = 850;

        if ( isdefined( level.airsupportheightscale ) )
        {
            level.airsupportheightscale = getdvarintdefault( "scr_airsupportHeightScale", level.airsupportheightscale );
            planeflyheight = planeflyheight * getdvarintdefault( "scr_airsupportHeightScale", level.airsupportheightscale );
        }

        if ( isdefined( level.forceairsupportmapheight ) )
            planeflyheight = planeflyheight + level.forceairsupportmapheight;
    }

    return planeflyheight;
}

qrdrone_watch_distance()
{
    self endon( "entityshutdown" );
    qrdrone_height = getstruct( "qrdrone_height", "targetname" );

    if ( isdefined( qrdrone_height ) )
        self.maxheight = qrdrone_height.origin[2];
    else
        self.maxheight = int( getminimumflyheight() );

    self.maxdistance = 12800;
    level.mapcenter = getmapcenter();
    self.minheight = level.mapcenter[2] - 800;
    inrangepos = self.origin;
    soundent = spawn( 0, self.origin, "script_origin" );
    soundent linkto( self );
    self thread qrdrone_staticstopondeath( soundent );

    while ( true )
    {
        if ( !self qrdrone_in_range() )
        {
            staticalpha = 0;

            while ( !self qrdrone_in_range() )
            {
                if ( isdefined( self.heliinproximity ) )
                {
                    dist = distance( self.origin, self.heliinproximity.origin );
                    staticalpha = 1 - ( dist - 150 ) / 150;
                }
                else
                {
                    dist = distance( self.origin, inrangepos );
                    staticalpha = min( 1, dist / 200 );
                }

                sid = soundent playloopsound( "veh_qrdrone_static_lp", 0.2 );
                self clientscripts\mp\_vehicle::set_static_amount( staticalpha * 2 );
                wait 0.05;
            }

            self thread qrdrone_staticfade( staticalpha, soundent, sid );
        }

        inrangepos = self.origin;
        wait 0.05;
    }
}

qrdrone_in_range()
{
    if ( self.origin[2] < self.maxheight && self.origin[2] > self.minheight )
    {
        if ( self isinsideheightlock() )
            return true;
    }

    return false;
}

qrdrone_staticfade( staticalpha, sndent, sid )
{
    self endon( "entityshutdown" );

    while ( self qrdrone_in_range() )
    {
        staticalpha = staticalpha - 0.05;

        if ( staticalpha <= 0 )
        {
            sndent stoploopsound( 0.5 );
            self clientscripts\mp\_vehicle::set_static_amount( 0 );
            break;
        }

        setsoundvolumerate( sid, 0.6 );
        setsoundvolume( sid, staticalpha );
        self clientscripts\mp\_vehicle::set_static_amount( staticalpha * 2 );
        wait 0.05;
    }
}

qrdrone_staticstopondeath( sndent )
{
    self waittill( "entityshutdown" );
    sndent stoploopsound( 0.1 );
    sndent delete();
}
