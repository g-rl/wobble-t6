// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_vehicle;
#include clientscripts\mp\_utility;

main()
{
    level._ai_tank_fx = [];
    level._ai_tank_fx["dirt"] = loadfx( "vehicle/treadfx/fx_treadfx_talon_dirt" );
    level._ai_tank_fx["concrete"] = loadfx( "vehicle/treadfx/fx_treadfx_talon_concrete" );
    level._ai_tank_fx["light_green"] = loadfx( "light/fx_vlight_talon_eye_grn" );
    level._ai_tank_fx["light_red"] = loadfx( "light/fx_vlight_talon_eye_red" );
    level._ai_tank_fx["stun"] = loadfx( "weapon/talon/fx_talon_emp_stun" );
    registerclientfield( "vehicle", "ai_tank_death", 1, 1, "int", ::death, 0 );
    registerclientfield( "vehicle", "ai_tank_missile_fire", 1, 3, "int", ::missile_fire, 0 );
    registerclientfield( "vehicle", "ai_tank_hack_spawned", 1, 1, "int", ::spawned, 0 );
    registerclientfield( "vehicle", "ai_tank_hack_rebooting", 1, 1, "int", ::rebooting, 0 );
    level._client_flag_callbacks["vehicle"][3] = ::tank_stun;
}

spawned( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self thread play_light_fx( localclientnum );
    self thread play_driving_fx( localclientnum );
    self thread play_driving_rumble( localclientnum );
}

#using_animtree("mp_vehicles");

missile_fire( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self useanimtree( #animtree );

    if ( newval == 2 )
        self setanimrestart( %o_drone_tank_missile1_fire, 1.0, 0.0, 0.5 );
    else if ( newval == 1 )
        self setanimrestart( %o_drone_tank_missile2_fire, 1.0, 0.0, 0.5 );
    else if ( newval == 0 )
        self setanimrestart( %o_drone_tank_missile3_fire, 1.0, 0.0, 0.5 );
    else if ( newval == 4 )
        self setanimrestart( %o_drone_tank_missile_full_reload, 1.0, 0.0, 1.0 );
}

play_light_fx( localclientnum )
{
    self notify( "light_disable" );
    self endon( "entityshutdown" );
    self endon( "light_disable" );
    self endon( "death" );
    self notify( "reboot_disable" );
    self waittill_dobj( localclientnum );
    self stop_light_fx( localclientnum );
    self start_light_fx( localclientnum );

    for (;;)
    {
        level waittill_any( "snap_processed", "demo_jump", "demo_player_switch" );

        if ( isdemoplaying() && getdvar( #"ui_gametype" ) == "hack" && codegetclientfield( self, "ai_tank_hack_spawned" ) <= 0 )
        {
            self stop_light_fx( localclientnum );
            return;
        }

        player = getlocalplayer( localclientnum );

        if ( !isdefined( player ) )
        {
            self stop_light_fx( localclientnum );
            continue;
        }
        else if ( isinvehicle( localclientnum, self ) )
            self stop_light_fx( localclientnum );
        else if ( player getinkillcam( localclientnum ) )
            continue;
        else if ( self.friend != self friendnotfoe( localclientnum ) )
            self stop_light_fx( localclientnum );

        if ( !isinvehicle( localclientnum, self ) && !isdefined( self.fx ) )
            self start_light_fx( localclientnum );
    }
}

tank_stun( localclientnum, set )
{
    self endon( "entityshutdown" );
    self endon( "death" );

    if ( set )
    {
        self notify( "light_disable" );
        self stop_light_fx( localclientnum );
        self stop_stun_fx( localclientnum );
        self start_stun_fx( localclientnum );
    }
    else
    {
        self thread play_light_fx( localclientnum );
        self stop_stun_fx( localclientnum );
    }
}

death( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    player = getlocalplayer( localclientnum );

    if ( !isdefined( player ) )
        return;

    if ( player getinkillcam( localclientnum ) )
        return;

    if ( newval )
    {
        self stop_light_fx( localclientnum );
        self stop_stun_fx( localclientnum );
        self notify( "light_disable" );
    }
}

start_light_fx( localclientnum )
{
    friend = self friendnotfoe( localclientnum );
    player = getlocalplayer( localclientnum );

    if ( isinvehicle( localclientnum, self ) )
        return;

    if ( friend )
    {
        self.fx = playfxontag( localclientnum, level._ai_tank_fx["light_green"], self, "tag_scanner" );
        self.friend = 1;
    }
    else
    {
        self.fx = playfxontag( localclientnum, level._ai_tank_fx["light_red"], self, "tag_scanner" );
        self.friend = 0;
    }
}

stop_light_fx( localclientnum )
{
    if ( isdefined( self.fx ) )
    {
        stopfx( localclientnum, self.fx );
        self.fx = undefined;
    }
}

start_stun_fx( localclientnum )
{
    self.stun_fx = playfxontag( localclientnum, level._ai_tank_fx["stun"], self, "tag_origin" );
    playsound( localclientnum, "veh_talon_shutdown", self.origin );
}

stop_stun_fx( localclientnum )
{
    if ( isdefined( self.stun_fx ) )
    {
        stopfx( localclientnum, self.stun_fx );
        self.stun_fx = undefined;
    }
}

play_driving_fx( localclientnum )
{
    self notify( "driving_fx" );
    self endon( "entityshutdown" );
    self endon( "driving_fx" );

    for (;;)
    {
        if ( self getspeed() >= 40 )
        {
            forward = anglestoforward( self.angles );
            up = anglestoup( self.angles );
            fx = self get_surface_fx();
            playfx( localclientnum, fx, self.origin, forward, up );
            wait 0.5;
            continue;
        }

        serverwait( localclientnum, 0.1 );
    }
}

play_driving_rumble( localclientnum )
{
    self notify( "driving_rumble" );
    self endon( "entityshutdown" );
    self endon( "death" );
    self endon( "driving_rumble" );

    for (;;)
    {
        if ( isinvehicle( localclientnum, self ) )
        {
            speed = self getspeed();

            if ( speed >= 40 || speed <= -40 )
            {
                player = getlocalplayer( localclientnum );

                if ( isdefined( player ) )
                    player earthquake( 0.1, 0.1, self.origin, 200 );
            }
        }

        serverwait( localclientnum, 0.05 );
    }
}

rebooting( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    player = getlocalplayer( localclientnum );

    if ( !isdefined( player ) )
        return;

    if ( player getinkillcam( localclientnum ) )
        return;

    if ( newval )
        self thread start_reboot_fx( localclientnum );
    else
    {
        self notify( "reboot_disable" );
        self stop_light_fx( localclientnum );
    }
}

start_reboot_fx( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "reboot_disable" );
    self endon( "death" );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.3 );
    self stop_light_fx( localclientnum );
    serverwait( localclientnum, 0.3 );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.2 );
    self stop_light_fx( localclientnum );
    serverwait( localclientnum, 0.2 );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.2 );
    self stop_light_fx( localclientnum );
    serverwait( localclientnum, 0.2 );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self stop_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self stop_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self stop_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self start_light_fx( localclientnum );
    serverwait( localclientnum, 0.1 );
    self stop_light_fx( localclientnum );
}

get_surface_fx()
{
    surface_type = self getwheelsurface( "front_right" );

    switch ( surface_type )
    {
        case "dirt":
        case "foliage":
        case "grass":
        case "gravel":
        case "mud":
        case "sand":
        case "water":
            return level._ai_tank_fx["dirt"];
    }

    return level._ai_tank_fx["concrete"];
}
