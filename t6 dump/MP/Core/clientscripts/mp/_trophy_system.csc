// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;

init( localclientnum )
{
    registerclientfield( "missile", "trophy_system_state", 1, 2, "int", ::trophy_state_change, 0 );
    registerclientfield( "scriptmover", "trophy_system_state", 1, 2, "int", ::trophy_state_change_recon, 0 );
    level._effect["fx_trophy_friendly_light"] = loadfx( "weapon/trophy_system/fx_trophy_light_friendly" );
    level._effect["fx_trophy_enemy_light"] = loadfx( "weapon/trophy_system/fx_trophy_light_enemy" );
    level._effect["fx_trophy_deploy_impact"] = loadfx( "weapon/trophy_system/fx_trophy_deploy_impact" );
}

spawned( localclientnum )
{
    self endon( "entityshutdown" );
    self thread trophy_fx( localclientnum );
}

trophy_fx( localclientnum )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );
    waittillsnapprocessed( localclientnum );
    fx_handle = self playflarefx( localclientnum );
    self notify( "teamBased_fx_reinitialized" );
    self thread checkforplayerswitch( localclientnum, fx_handle );
    level thread watchforplayerrespawnforteambasedfx( localclientnum, self, ::trophy_fx, fx_handle );
}

playflarefx( localclientnum )
{
    self endon( "entityshutdown" );
    level endon( "player_switch" );

    if ( friendnotfoe( localclientnum ) )
        fx_handle = playfxontag( localclientnum, level._effect["fx_trophy_friendly_light"], self, "tag_light_fx" );
    else
        fx_handle = playfxontag( localclientnum, level._effect["fx_trophy_enemy_light"], self, "tag_light_fx" );

    self thread watchtrophyshutdown( localclientnum, fx_handle );
    return fx_handle;
}

watchtrophyshutdown( localclientnum, fxhandle )
{
    msg = self waittill_any_return( "entityshutdown", "team_changed", "player_switch" );
    stopfx( localclientnum, fxhandle );

    if ( msg == "team_changed" )
        self thread trophy_fx( localclientnum );
}

checkforplayerswitch( localclientnum, fxhandle )
{
    self endon( "entityshutdown" );
    self endon( "teamBased_fx_reinitialized" );
    level waittill( "player_switch" );
    self notify( "player_switch" );

    if ( isdefined( fxhandle ) )
        stopfx( localclientnum, fxhandle );

    waittillframeend;
    self thread trophy_fx( localclientnum );
}

trophy_state_change( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );

    if ( !isdefined( self ) )
        return;

    switch ( newval )
    {
        case 1:
            self thread trophy_deploy_anim( localclientnum, 1 );
            break;
        case 2:
            break;
    }
}

trophy_state_change_recon( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );

    if ( !isdefined( self ) )
        return;

    switch ( newval )
    {
        case 1:
            self thread trophy_deploy_anim( localclientnum, 0 );
            break;
        case 2:
            break;
    }
}

#using_animtree("mp_trophy_system");

trophy_deploy_anim( localclientnum, playfx )
{
    self endon( "entityshutdown" );
    self useanimtree( #animtree );
    self setanim( %o_trophy_deploy, 1.0, 0.0, 1.0 );

    if ( playfx )
        playfxontag( localclientnum, level._effect["fx_trophy_deploy_impact"], self, "tag_origin" );

    wait 0.3;
    self useanimtree( #animtree );
    self setanim( %o_trophy_spin, 1.0, 0.0, 1.4 );
}
