// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rcbomb;
#include clientscripts\mp\_qrdrone;
#include clientscripts\mp\_ai_tank;
#include clientscripts\mp\_missile_swarm;

init_vehicles()
{
    level.vehicles_inited = 1;
    clientscripts\mp\_rcbomb::main();
    clientscripts\mp\_qrdrone::main();
    clientscripts\mp\_ai_tank::main();
    clientscripts\mp\_missile_swarm::main();
}

vehicle_rumble( localclientnum )
{
    self endon( "entityshutdown" );

    if ( !isdefined( level.vehicle_rumble ) )
        return;

    type = self.vehicletype;

    if ( !isdefined( level.vehicle_rumble[type] ) )
        return;

    rumblestruct = level.vehicle_rumble[type];
    height = rumblestruct.radius * 2;
    zoffset = -1 * rumblestruct.radius;

    if ( !isdefined( self.rumbleon ) )
        self.rumbleon = 1;

    if ( isdefined( rumblestruct.scale ) )
        self.rumble_scale = rumblestruct.scale;
    else
        self.rumble_scale = 0.15;

    if ( isdefined( rumblestruct.duration ) )
        self.rumble_duration = rumblestruct.duration;
    else
        self.rumble_duration = 4.5;

    if ( isdefined( rumblestruct.radius ) )
        self.rumble_radius = rumblestruct.radius;
    else
        self.rumble_radius = 600;

    if ( isdefined( rumblestruct.basetime ) )
        self.rumble_basetime = rumblestruct.basetime;
    else
        self.rumble_basetime = 1;

    if ( isdefined( rumblestruct.randomaditionaltime ) )
        self.rumble_randomaditionaltime = rumblestruct.randomaditionaltime;
    else
        self.rumble_randomaditionaltime = 1;

    self.player_touching = 0;
    radius_squared = rumblestruct.radius * rumblestruct.radius;

    while ( true )
    {
        if ( distancesquared( self.origin, level.localplayers[localclientnum].origin ) > radius_squared || self getspeed() < 35 )
        {
            wait 0.2;
            continue;
        }

        if ( isdefined( self.rumbleon ) && !self.rumbleon )
        {
            wait 0.2;
            continue;
        }

        self playrumblelooponentity( localclientnum, level.vehicle_rumble[type].rumble );

        while ( distancesquared( self.origin, level.localplayers[localclientnum].origin ) < radius_squared && self getspeed() > 5 )
            wait( self.rumble_basetime + randomfloat( self.rumble_randomaditionaltime ) );

        self stoprumble( localclientnum, level.vehicle_rumble[type].rumble );
    }
}

vehicle_treads( localclientnum )
{
    if ( !isdefined( self.treadfx ) )
        self.treadfx = [];

    if ( !isdefined( level.vehicles_inited ) )
        return;

    self thread tread( localclientnum, "tag_wheel_back_left", "back_left" );
    self thread tread( localclientnum, "tag_wheel_back_right", "back_right" );
}

vehicle_kill_treads_forever()
{
    self notify( "kill_treads_forever" );
}

tread( localclientnum, tagname, side, relativeoffset )
{
    self endon( "entityshutdown" );
    self endon( "kill_treads_forever" );
    level endon( "kill_treads_forever" );
    treadfx = treadget( self, side );

    if ( treadfx == -1 )
        return;

    for (;;)
    {
        speed = self getspeed();

        if ( speed < 25 )
        {
            wait 0.1;
            continue;
        }

        waittime = 1 / speed;
        waittime = waittime * 35;

        if ( waittime < 0.1 )
            waittime = 0.1;
        else if ( waittime > 0.3 )
            waittime = 0.3;

        wait( waittime );
        lastfx = treadfx;
        treadfx = treadget( self, side );

        if ( treadfx != -1 )
        {
            ang = self gettagangles( tagname );
            forwardvec = anglestoforward( ang );
            effectorigin = self gettagorigin( tagname );
            forwardvec = vectorscale( forwardvec, waittime );
            playfx( localclientnum, treadfx, effectorigin, ( 0, 0, 0 ) - forwardvec );
        }
    }
}

treadget( vehicle, side )
{
    surface = self getwheelsurface( side );

    if ( !isdefined( vehicle.treadfx ) )
    {
/#
        println( "clientside treadfx not setup for vehicle type: ", vehicle.vehicletype );
#/
        wait 10;
        return -1;
    }

    treadfx = vehicle.treadfx[surface];

    if ( !isdefined( treadfx ) )
        treadfx = -1;

    return treadfx;
}

playtankexhaust( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "stop_exhaust_fx" );
    level endon( "stop_exhaust_fx" );
    exhaustdelay = 0.1;

    for (;;)
    {
        if ( !isdefined( self ) || !self isalive() )
            return;
        else if ( !isdefined( level.vehicle_exhaust ) || !isdefined( level.vehicle_exhaust[self.model] ) )
        {
/#
            println( "clientside exhaustfx not set up for vehicle model: " + self.model );
#/
            return;
        }

        tag_left_orig = self gettagorigin( "tag_engine_left" );
        tag_left_angles = self gettagangles( "tag_engine_left" );

        if ( self getspeed() > 0 )
        {
            playfx( localclientnum, level.vehicle_exhaust[self.model].exhaust_fx, tag_left_orig, anglestoforward( tag_left_angles ) );

            if ( !level.vehicle_exhaust[self.model].one_exhaust )
            {
                tag_right_orig = self gettagorigin( "tag_engine_right" );
                tag_right_angles = self gettagangles( "tag_engine_right" );
                playfx( localclientnum, level.vehicle_exhaust[self.model].exhaust_fx, tag_right_orig, anglestoforward( tag_right_angles ) );
            }
        }

        wait( exhaustdelay );
    }
}

build_exhaust( model, effect, one_exhaust )
{
/#
    println( "building exhaust for " + model );
#/

    if ( !isdefined( level.vehicle_exhaust ) )
        level.vehicle_exhaust = [];

    level.vehicle_exhaust[model] = spawnstruct();
    level.vehicle_exhaust[model].exhaust_fx = loadfx( effect );

    if ( isdefined( one_exhaust ) && one_exhaust )
        level.vehicle_exhaust[model].one_exhaust = 1;
    else
        level.vehicle_exhaust[model].one_exhaust = 0;
}

build_gear( vehicletype, model, tag )
{
    index = 0;

    if ( isdefined( level.vehiclegearmodels ) )
    {
        if ( isdefined( level.vehiclegearmodels[vehicletype] ) )
            index = level.vehiclegearmodels[vehicletype].size;
    }

    level.vehiclegearmodels[vehicletype][index] = model;
    level.vehiclegeartags[vehicletype][index] = tag;
}

build_quake( scale, duration, radius, basetime, randomaditionaltime )
{
    struct = spawnstruct();
    struct.scale = scale;
    struct.duration = duration;
    struct.radius = radius;

    if ( isdefined( basetime ) )
        struct.basetime = basetime;

    if ( isdefined( randomaditionaltime ) )
        struct.randomaditionaltime = randomaditionaltime;

    return struct;
}

build_rumble( type, rumble, scale, duration, radius, basetime, randomaditionaltime )
{
/#
    println( "*** Client : Building rumble for " + type );
#/

    if ( !isdefined( level.vehicle_rumble ) )
        level.vehicle_rumble = [];

    struct = build_quake( scale, duration, radius, basetime, randomaditionaltime );
    assert( isdefined( rumble ) );
    struct.rumble = precacherumble( rumble );
    level.vehicle_rumble[type] = struct;
}

set_static_amount( staticamount )
{
    driverlocalclient = self getlocalclientdriver();

    if ( isdefined( driverlocalclient ) )
    {
        driver = getlocalplayer( driverlocalclient );

        if ( isdefined( driver ) )
            driver set_filter_pass_constant( 4, 0, 1, staticamount );
    }
}

vehicle_variants( localclientnum )
{

}
