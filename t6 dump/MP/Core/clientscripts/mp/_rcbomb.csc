// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_vehicle;
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;
#include clientscripts\mp\_callbacks;

main()
{
    type = "rc_car_medium_mp";
    loadtreadfx( "dust" );
    loadtreadfx( "concrete" );
    level._effect["rcbomb_enemy_light"] = loadfx( "vehicle/light/fx_rcbomb_blinky_light" );
    level._effect["rcbomb_friendly_light"] = loadfx( "vehicle/light/fx_rcbomb_solid_light" );
    level._effect["rcbomb_enemy_light_blink"] = loadfx( "vehicle/light/fx_rcbomb_light_red_os" );
    level._effect["rcbomb_friendly_light_blink"] = loadfx( "vehicle/light/fx_rcbomb_light_green_os" );
    level._effect["rcbomb_stunned"] = loadfx( "weapon/grenade/fx_spark_disabled_rc_car" );
    registerclientfield( "vehicle", "rcbomb_death", 1, 1, "int", ::death, 0 );
    registerclientfield( "vehicle", "rcbomb_countdown", 1, 2, "int", ::countdown, 0 );
    level._client_flag_callbacks["vehicle"][9] = clientscripts\mp\_callbacks::stunned_callback;
    level.rcbombsurfacetypeforscreenfx = ::default_surface_type_for_screen_fx;
    level.rcbombsurfacetypefortreadfx = ::default_surface_type_for_tread_fx;
}

loadtreadfx( type )
{
    if ( !isdefined( level._effect[type] ) )
        level._effect[type] = [];

    level._effect[type]["rcbomb_driving_1st"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_first_person" );
    level._effect[type]["rcbomb_driving_slow_1st"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_slow" );
    level._effect[type]["rcbomb_driving_reverse_1st"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_reverse" );
    level._effect[type]["rcbomb_driving_trail_1st"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_trail" );
    level._effect[type]["rcbomb_sliding_1st"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_drift" );
    level._effect[type]["rcbomb_peeling_out_1st"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_peel" );
    level._effect[type]["rcbomb_driving_3rd"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type );
    level._effect[type]["rcbomb_driving_slow_3rd"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_slow" );
    level._effect[type]["rcbomb_driving_reverse_3rd"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_reverse" );
    level._effect[type]["rcbomb_driving_trail_3rd"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_trail" );
    level._effect[type]["rcbomb_sliding_3rd"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_drift" );
    level._effect[type]["rcbomb_peeling_out_3rd"] = loadfx( "vehicle/treadfx/fx_treadfx_rcbomb_" + type + "_peel" );
}

spawned( localclientnum )
{
    self thread spawn_solid_fx( localclientnum );
    self thread demo_think( localclientnum );
    self thread play_driving_fx( localclientnum );
    self thread collisionhandler( localclientnum );
    self thread stunnedhandler( localclientnum );
    self thread slidehandler( localclientnum );
}

spawn_solid_fx( localclientnum )
{
    if ( codegetclientfield( self, "rcbomb_countdown" ) > 0 )
        return;

    self notify( "light_disable" );
    self endon( "entityshutdown" );
    self endon( "light_disable" );
    self waittill_dobj( localclientnum );
    self stop_light_fx( localclientnum );
    self start_light_fx( localclientnum );

    for (;;)
    {
        level waittill( "snap_processed" );
        player = getlocalplayer( localclientnum );

        if ( !isdefined( player ) )
        {
            self stop_light_fx( localclientnum );
            continue;
        }
        else if ( player getinkillcam( localclientnum ) )
            continue;
        else if ( self.friend != self friendnotfoe( localclientnum ) )
            self stop_light_fx( localclientnum );

        if ( !isdefined( self.fx ) || self.fx == 0 )
            self start_light_fx( localclientnum );
    }
}

death( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
    {
        self stop_light_fx( localclientnum );
        self notify( "light_disable" );
    }
}

start_light_fx( localclientnum, blink )
{
    if ( !isdefined( blink ) )
        blink = 0;

    friend = self friendnotfoe( localclientnum );
    player = getlocalplayer( localclientnum );

    if ( friend )
    {
        if ( blink )
            self.fx = playfxontag( localclientnum, level._effect["rcbomb_friendly_light_blink"], self, "tag_origin" );
        else
            self.fx = playfxontag( localclientnum, level._effect["rcbomb_friendly_light"], self, "tag_origin" );

        self.friend = 1;
    }
    else
    {
        if ( blink )
            self.fx = playfxontag( localclientnum, level._effect["rcbomb_enemy_light_blink"], self, "tag_origin" );
        else
            self.fx = playfxontag( localclientnum, level._effect["rcbomb_enemy_light"], self, "tag_origin" );

        self.friend = 0;
    }
}

stop_light_fx( localclientnum )
{
    if ( isdefined( self.fx ) && self.fx != 0 )
    {
        stopfx( localclientnum, self.fx );
        self.fx = undefined;
    }
}

countdown( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !newval )
        return;

    self notify( "light_disable" );
    self endon( "entityshutdown" );
    self endon( "light_disable" );
    interval = 1;

    if ( newval == 2 )
        interval = 0.133;

    self stop_light_fx( localclientnum );

    for (;;)
    {
        self playsound( localclientnum, "wpn_crossbow_alert" );
        self start_light_fx( localclientnum, 1 );
        serverwait( localclientnum, interval );
        interval = clamp( interval / 1.17, 0.1, 1 );
    }
}

demo_think( localclientnum )
{
    self endon( "entityshutdown" );

    if ( !isdemoplaying() )
        return;

    for (;;)
    {
        level waittill_any( "demo_jump", "demo_player_switch" );
        self stop_light_fx( localclientnum );
        self thread spawn_solid_fx( localclientnum );
    }
}

play_screen_fx_dirt( localclientnum )
{
    pick_one = randomintrange( 0, 4 );

    if ( pick_one == 0 )
        animateui( localclientnum, "fullscreen_dirt", "dirt", "in", 0 );
    else if ( pick_one == 1 )
        animateui( localclientnum, "fullscreen_dirt", "dirt_right_splash", "in", 0 );
    else if ( pick_one == 2 )
        animateui( localclientnum, "fullscreen_dirt", "dirt_left_splash", "in", 0 );
    else
        animateui( localclientnum, "fullscreen_dirt", "blurred_dirt_random", "in", 0 );
}

play_screen_fx_dust( localclientnum )
{
    pick_one = randomintrange( 0, 4 );

    if ( pick_one == 0 )
        animateui( localclientnum, "fullscreen_dust", "dust", "in", 0 );
    else if ( pick_one == 1 )
        animateui( localclientnum, "fullscreen_dust", "dust_right_splash", "in", 0 );
    else if ( pick_one == 2 )
        animateui( localclientnum, "fullscreen_dust", "dust_left_splash", "in", 0 );
    else
        animateui( localclientnum, "fullscreen_dust", "blurred_dust_random", "in", 0 );
}

play_driving_fx_firstperson( localclientnum, speed, speed_fraction, surf_type )
{
    play_trail = 0;

    if ( !isdefined( level._effect[surf_type] ) )
    {
/#
        println( "Surface type: " + surf_type + " is not defined for the rcxd road fx" );
#/
        return;
    }

    if ( self ispeelingout() )
    {
        play_trail = 1;
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_peeling_out_1st"], self, "tag_origin" );
    }

    if ( self iswheelsliding( "back_left" ) || self iswheelsliding( "back_right" ) )
    {
        play_trail = 1;
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_sliding_1st"], self, "tag_origin" );
    }

    slow_speed = 5;
    normal_speed_fraction = 0.25;
    decelerating_speed_fraction = 0.4;
    decelerating_throttle_fraction = 0.25;
    throttle = self getthrottle();

    if ( speed < slow_speed * -1 )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_reverse_1st"], self, "tag_origin" );
    else if ( speed_fraction >= normal_speed_fraction && !( speed_fraction < decelerating_speed_fraction && throttle < decelerating_throttle_fraction ) )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_1st"], self, "tag_origin" );
    else if ( speed > slow_speed )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_slow_1st"], self, "tag_origin" );

    if ( speed_fraction >= 0.75 && speed > 0 )
        play_trail = 1;

    if ( play_trail )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_trail_1st"], self, "tag_origin" );

    if ( !issplitscreen() && speed > 0 && speed_fraction >= normal_speed_fraction )
    {
        viewangles = getlocalclientangles( localclientnum );
        pitch = viewangles[0];
        max_additional_time = 1000;
        no_effects_pitch = 40.0;
        full_effects_pitch = 20.0;

        if ( pitch < no_effects_pitch )
        {
            current_additional_time = 0;

            if ( pitch > full_effects_pitch )
                current_additional_time = max_additional_time * ( ( pitch - full_effects_pitch ) / ( no_effects_pitch - full_effects_pitch ) );

            if ( self.last_screen_dirt + self.screen_dirt_delay + current_additional_time < getrealtime() )
            {
                screen_fx_type = self [[ level.rcbombsurfacetypeforscreenfx ]]();

                if ( screen_fx_type == "dirt" )
                    play_screen_fx_dirt( localclientnum );
                else
                    play_screen_fx_dust( localclientnum );

                self.last_screen_dirt = getrealtime();
                self.screen_dirt_delay = randomintrange( 250, 500 );
            }
        }
    }
}

play_driving_fx_thirdperson( localclientnum, speed, speed_fraction, surf_type )
{
    play_trail = 0;

    if ( !isdefined( level._effect[surf_type] ) )
    {
/#
        println( "Surface type: " + surf_type + " is not defined for the rcxd road fx" );
#/
        return;
    }

    if ( self ispeelingout() )
    {
        play_trail = 1;
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_peeling_out_3rd"], self, "tag_origin" );
    }

    if ( self iswheelsliding( "back_left" ) || self iswheelsliding( "back_right" ) )
    {
        play_trail = 1;
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_sliding_3rd"], self, "tag_origin" );
    }

    slow_speed = 5;
    normal_speed_fraction = 0.25;

    if ( speed < slow_speed * -1 )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_reverse_3rd"], self, "tag_origin" );
    else if ( speed_fraction >= normal_speed_fraction )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_3rd"], self, "tag_origin" );
    else if ( speed > slow_speed )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_slow_3rd"], self, "tag_origin" );

    if ( speed_fraction >= 0.75 && speed > 0 )
        play_trail = 1;

    if ( play_trail )
        playfxontag( localclientnum, level._effect[surf_type]["rcbomb_driving_trail_3rd"], self, "tag_origin" );
}

play_driving_screen_fx( localclientnum )
{
    speed_fraction = 0;

    while ( true )
    {
        speed = self getspeed();
        maxspeed = self getmaxspeed();

        if ( speed < 0 )
            maxspeed = self getmaxreversespeed();

        if ( maxspeed > 0 )
            speed_fraction = abs( speed ) / maxspeed;
        else
            speed_fraction = 0;

        if ( self iswheelcolliding( "back_left" ) || self iswheelcolliding( "back_right" ) )
        {
            if ( self islocalclientdriver( localclientnum ) )
            {

            }
        }
    }
}

play_driving_fx( localclientnum )
{
    self endon( "entityshutdown" );
    self thread play_boost_fx( localclientnum );
    self.last_screen_dirt = 0;
    self.screen_dirt_delay = 0;
    speed_fraction = 0;

    while ( true )
    {
        speed = self getspeed();
        maxspeed = self getmaxspeed();

        if ( speed < 0 )
            maxspeed = self getmaxreversespeed();

        if ( maxspeed > 0 )
            speed_fraction = abs( speed ) / maxspeed;
        else
            speed_fraction = 0;

        if ( self iswheelcolliding( "back_left" ) || self iswheelcolliding( "back_right" ) )
        {
            surf_type = self [[ level.rcbombsurfacetypefortreadfx ]]();

            if ( isdefined( surf_type ) )
            {
                if ( self islocalclientdriver( localclientnum ) )
                    play_driving_fx_firstperson( localclientnum, speed, speed_fraction, surf_type );
                else
                    play_driving_fx_thirdperson( localclientnum, speed, speed_fraction, surf_type );
            }
        }

        serverwait( localclientnum, 0.1 );
    }
}

play_boost_fx( localclientnum )
{
    self endon( "entityshutdown" );

    while ( true )
    {
        speed = self getspeed();

        if ( speed > 400 )
        {
            self playsound( localclientnum, "mpl_veh_rc_boost" );
            return;
        }

        serverwait( localclientnum, 0.1 );
    }
}

collisionhandler( localclientnum )
{
    self endon( "entityshutdown" );

    while ( true )
    {
        self waittill( "veh_collision", hip, hitn, hit_intensity );
        driver_local_client = self getlocalclientdriver();

        if ( isdefined( driver_local_client ) )
        {
            player = getlocalplayer( driver_local_client );

            if ( isdefined( player ) )
            {
                if ( hit_intensity > 15 )
                    player playrumbleonentity( driver_local_client, "damage_heavy" );
                else
                    player playrumbleonentity( driver_local_client, "damage_light" );
            }
        }
    }
}

stunnedhandler( localclientnum )
{
    self endon( "entityshutdown" );
    self thread enginestutterhandler( localclientnum );

    while ( true )
    {
        self waittill( "stunned" );
        self setstunned( 1 );
        self thread notstunnedhandler( localclientnum );
        self thread play_stunned_fx_handler( localclientnum );
    }
}

notstunnedhandler( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "stunned" );
    self waittill( "not_stunned" );
    self setstunned( 0 );
}

play_stunned_fx_handler( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "stunned" );
    self endon( "not_stunned" );

    while ( true )
    {
        playfxontag( localclientnum, level._effect["rcbomb_stunned"], self, "tag_origin" );
        wait 0.5;
    }
}

enginestutterhandler( localclientnum )
{
    self endon( "entityshutdown" );

    while ( true )
    {
        self waittill( "veh_engine_stutter" );

        if ( self islocalclientdriver( localclientnum ) )
        {
            player = getlocalplayer( localclientnum );

            if ( isdefined( player ) )
                player playrumbleonentity( localclientnum, "rcbomb_engine_stutter" );
        }
    }
}

slidehandler( localclientnum )
{
    self endon( "entityshutdown" );
    slide_start_time = 0;

    while ( true )
    {
        if ( self islocalclientdriver( localclientnum ) )
        {
            player = getlocalplayer( localclientnum );

            if ( isdefined( player ) )
            {
                if ( self ispeelingout() || self iswheelsliding( "back_left" ) && self iswheelsliding( "back_right" ) )
                {
                    if ( slide_start_time == 0 )
                        slide_start_time = getrealtime();

                    if ( slide_start_time + 200 < getrealtime() )
                        player playrumbleonentity( localclientnum, "rcbomb_slide" );
                }
                else
                    slide_start_time = 0;
            }
        }

        serverwait( localclientnum, 0.3 );
    }
}

default_dirt_surface_type( surface_type )
{
    switch ( surface_type )
    {
        case "dirt":
        case "foliage":
        case "grass":
        case "gravel":
        case "mud":
        case "sand":
        case "water":
            return true;
    }

    return false;
}

default_snow_surface_type( surface_type )
{
    switch ( surface_type )
    {
        case "ice":
        case "snow":
            return true;
    }

    return false;
}

default_concrete_surface_type( surface_type )
{
    switch ( surface_type )
    {
        case "asphalt":
        case "brick":
        case "ceramic":
        case "concrete":
        case "glass":
        case "metal":
        case "none":
        case "paintedmetal":
        case "plaster":
        case "rock":
            return true;
    }

    return false;
}

snowy_level_snow_surface_type( surface_type )
{
    switch ( surface_type )
    {
        case "asphalt":
        case "brick":
        case "concrete":
        case "dirt":
        case "foliage":
        case "grass":
        case "gravel":
        case "ice":
        case "mud":
        case "rock":
        case "sand":
        case "snow":
        case "water":
            return true;
    }

    return false;
}

snowy_level_concrete_surface_type( surface_type )
{
    switch ( surface_type )
    {
        case "ceramic":
        case "glass":
        case "metal":
        case "none":
        case "paintedmetal":
        case "plaster":
        case "rock":
            return true;
    }

    return false;
}

default_surface_type_for_screen_fx()
{
    right_rear = self getwheelsurface( "back_right" );
    left_rear = self getwheelsurface( "back_left" );

    if ( default_dirt_surface_type( right_rear ) )
        return "dirt";

    if ( default_dirt_surface_type( left_rear ) )
        return "dirt";

    if ( default_snow_surface_type( right_rear ) )
        return "snow";

    if ( default_snow_surface_type( left_rear ) )
        return "snow";

    return "dust";
}

default_surface_type_for_tread_fx()
{
    right_rear = self getwheelsurface( "back_right" );
    left_rear = self getwheelsurface( "back_left" );

    if ( default_snow_surface_type( right_rear ) || default_snow_surface_type( left_rear ) )
        return "snow";

    if ( default_dirt_surface_type( right_rear ) || default_dirt_surface_type( left_rear ) )
        return "dust";

    if ( default_concrete_surface_type( right_rear ) || default_concrete_surface_type( left_rear ) )
        return "concrete";

    return undefined;
}

snowy_level_surface_type_for_screen_fx()
{
    return default_surface_type_for_screen_fx();
}

snowy_level_surface_type_for_tread_fx()
{
    return default_surface_type_for_tread_fx();
}
