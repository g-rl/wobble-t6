// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;
#include clientscripts\mp\_audio;

init()
{
    level._effect["tacticalInsertionFriendly"] = loadfx( "misc/fx_equip_tac_insert_light_grn" );
    level._effect["tacticalInsertionEnemy"] = loadfx( "misc/fx_equip_tac_insert_light_red" );
    level._client_flag_callbacks["scriptmover"][2] = ::spawned;
    latlongstruct = getstruct( "lat_long", "targetname" );

    if ( isdefined( latlongstruct ) )
    {
        mapx = latlongstruct.origin[0];
        mapy = latlongstruct.origin[1];
        lat = latlongstruct.script_vector[0];
        long = latlongstruct.script_vector[1];
    }
    else
    {
        if ( isdefined( level.worldmapx ) && isdefined( level.worldmapy ) )
        {
            mapx = level.worldmapx;
            mapy = level.worldmapy;
        }
        else
        {
            mapx = 0.0;
            mapy = 0.0;
        }

        if ( isdefined( level.worldlat ) && isdefined( level.worldlong ) )
        {
            lat = level.worldlat;
            long = level.worldlong;
        }
        else
        {
            lat = 34.0216;
            long = -118.449;
        }
    }

    setmaplatlong( mapx, mapy, long, lat );
}

spawned( localclientnum, set )
{
    if ( !set )
        return;

    self thread tactical_insertion_fx( localclientnum );
}

tactical_insertion_fx( localclientnum )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );
    waittillsnapprocessed( localclientnum );
    fx_handle = self playflarefx( localclientnum );
    self notify( "teamBased_fx_reinitialized" );
    self thread checkforplayerswitch( localclientnum );
    level thread watchforplayerrespawnforteambasedfx( localclientnum, self, ::tactical_insertion_fx, fx_handle );
}

playflarefx( localclientnum )
{
    self endon( "entityshutdown" );
    level endon( "player_switch" );

    if ( friendnotfoe( localclientnum ) )
        self.tacticalinsertionfx = playfxontag( localclientnum, level._effect["tacticalInsertionFriendly"], self, "tag_flash" );
    else
        self.tacticalinsertionfx = playfxontag( localclientnum, level._effect["tacticalInsertionEnemy"], self, "tag_flash" );

    self thread watchtacinsertshutdown( localclientnum, self.tacticalinsertionfx );
    looporigin = self.origin;
    playloopat( "fly_tinsert_beep", looporigin );
    self thread stopflareloopwatcher( looporigin );
    return self.tacticalinsertionfx;
}

watchtacinsertshutdown( localclientnum, fxhandle )
{
    self waittill( "entityshutdown" );
    stopfx( localclientnum, fxhandle );
}

stopflareloopwatcher( looporigin )
{
    while ( true )
    {
        if ( !isdefined( self.tacticalinsertionfx ) )
        {
            stoploopat( "fly_tinsert_beep", looporigin );
            break;
        }

        wait 0.5;
    }
}

checkforplayerswitch( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "teamBased_fx_reinitialized" );

    while ( true )
    {
        level waittill( "player_switch" );

        if ( isdefined( self.tacticalinsertionfx ) )
        {
            stopfx( localclientnum, self.tacticalinsertionfx );
            self.tacticalinsertionfx = undefined;
        }

        waittillframeend;
        self thread playflarefx( localclientnum );
    }
}
