// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_ambientpackage;

audio_init( localclientnum )
{
    waitforclient( 0 );

    if ( localclientnum == 0 )
    {
        snd_snapshot_init();
        startsoundrandoms( localclientnum );
        startsoundloops();
        startlineemitters();
        thread bump_trigger_start( localclientnum );
        thread init_audio_triggers( localclientnum );
        thread snd_mp_end_round();
        thread snd_final_killcam();
        thread snd_killstreak_reaper();
        thread global_futz_watcher();
        thread clientvoicesetup();
        level thread post_match_snapshot();
    }
}

clientvoicesetup()
{
    if ( isdefined( level.clientvoicesetup ) )
    {
        [[ level.clientvoicesetup ]]();
        return;
    }

    player = getlocalplayers()[0];
    player.teamclientprefix = "vox_gen";
    thread sndvonotify( "playerbreathinsound", "sinper_hold" );
    thread sndvonotify( "playerbreathoutsound", "sinper_exhale" );
    thread sndvonotify( "playerbreathgaspsound", "sinper_gasp" );
}

sndvonotify( notifystring, dialog )
{
    player = getlocalplayers()[0];

    for (;;)
    {
        player waittill( notifystring );
        soundalias = player.teamclientprefix + "_" + dialog;
        player playsound( 0, soundalias );
    }
}

snd_snapshot_init()
{
    level._sndactivesnapshot = "default";
    level._sndnextsnapshot = "default";
    setgroupsnapshot( level._sndactivesnapshot );
    thread snd_snapshot_think();
}

snd_set_snapshot( state )
{
    level._sndnextsnapshot = state;
/#
    println( "snd duck debug: set state '" + state + "'" );
#/
    level notify( "new_bus" );
}

snd_snapshot_think()
{
    for (;;)
    {
        if ( level._sndactivesnapshot == level._sndnextsnapshot )
            level waittill( "new_bus" );

        if ( level._sndactivesnapshot == level._sndnextsnapshot )
            continue;

        assert( isdefined( level._sndnextsnapshot ) );
        assert( isdefined( level._sndactivesnapshot ) );
        setgroupsnapshot( level._sndnextsnapshot );
        level._sndactivesnapshot = level._sndnextsnapshot;
    }
}

snd_mp_end_round()
{
    level waittill( "snd_end_rnd" );
/#
    println( "setting round end snapshot" );
#/
    snd_set_snapshot( "mpl_round_end" );
}

soundrandom_thread( localclientnum, randsound )
{
    if ( !isdefined( randsound.script_wait_min ) )
        randsound.script_wait_min = 1;

    if ( !isdefined( randsound.script_wait_max ) )
        randsound.script_wait_max = 3;

/#
    if ( getdvarint( #"debug_audio" ) > 0 )
    {

    }
#/

    if ( !isdefined( randsound.script_scripted ) && isdefined( randsound.script_sound ) )
    {
        createsoundrandom( randsound.origin, randsound.script_sound, randsound.script_wait_min, randsound.script_wait_max );
        return;
    }

    while ( true )
    {
        wait( randomfloatrange( randsound.script_wait_min, randsound.script_wait_max ) );

        if ( !isdefined( randsound.script_sound ) )
        {

        }
        else
            playsound( localclientnum, randsound.script_sound, randsound.origin );

/#
        if ( getdvarint( #"debug_audio" ) > 0 )
            print3d( randsound.origin, randsound.script_sound, vectorscale( ( 0, 1, 0 ), 0.8 ), 1, 3, 45 );
#/
    }
}

startsoundrandoms( localclientnum )
{
    randoms = getstructarray( "random", "script_label" );

    if ( isdefined( randoms ) && randoms.size > 0 )
    {
        nscriptthreadedrandoms = 0;

        for ( i = 0; i < randoms.size; i++ )
        {
            if ( isdefined( randoms[i].script_scripted ) )
                nscriptthreadedrandoms++;
        }

        allocatesoundrandoms( randoms.size - nscriptthreadedrandoms );

        for ( i = 0; i < randoms.size; i++ )
            thread soundrandom_thread( localclientnum, randoms[i] );
    }
    else
    {

    }
}

soundloopthink()
{
    if ( !isdefined( self.script_sound ) )
        return;

    if ( !isdefined( self.origin ) )
        return;

    notifyname = "";
    assert( isdefined( notifyname ) );

    if ( isdefined( self.script_string ) )
        notifyname = self.script_string;

    assert( isdefined( notifyname ) );
    started = 1;

    if ( isdefined( self.script_int ) )
        started = self.script_int != 0;

    if ( started )
        soundloopemitter( self.script_sound, self.origin );

    if ( notifyname != "" )
    {
        for (;;)
        {
            level waittill( notifyname );

            if ( started )
                soundstoploopemitter( self.script_sound, self.origin );
            else
                soundloopemitter( self.script_sound, self.origin );

            started = !started;
        }
    }
    else
    {

    }
}

soundlinethink()
{
    if ( !isdefined( self.target ) )
        return;

    target = getstruct( self.target, "targetname" );

    if ( !isdefined( target ) )
        return;

    notifyname = "";

    if ( isdefined( self.script_string ) )
        notifyname = self.script_string;

    started = 1;

    if ( isdefined( self.script_int ) )
        started = self.script_int != 0;

    if ( started )
        soundlineemitter( self.script_sound, self.origin, target.origin );

    if ( notifyname != "" )
    {
        for (;;)
        {
            level waittill( notifyname );

            if ( started )
                soundstoplineemitter( self.script_sound, self.origin, target.origin );
            else
                soundlineemitter( self.script_sound, self.origin, target.origin );

            started = !started;
        }
    }
    else
    {

    }
}

startsoundloops()
{
    loopers = getstructarray( "looper", "script_label" );

    if ( isdefined( loopers ) && loopers.size > 0 )
    {
        delay = 0;
/#
        if ( getdvarint( #"debug_audio" ) > 0 )
            println( "*** Client : Initialising looper sounds - " + loopers.size + " emitters." );
#/

        for ( i = 0; i < loopers.size; i++ )
        {
            loopers[i] thread soundloopthink();
            delay = delay + 1;

            if ( delay % 20 == 0 )
                wait 0.01;
        }
    }
    else
    {
/#
        if ( getdvarint( #"debug_audio" ) > 0 )
            println( "*** Client : No looper sounds." );
#/
    }
}

startlineemitters()
{
    lineemitters = getstructarray( "line_emitter", "script_label" );

    if ( isdefined( lineemitters ) && lineemitters.size > 0 )
    {
        delay = 0;
/#
        if ( getdvarint( #"debug_audio" ) > 0 )
            println( "*** Client : Initialising line emitter sounds - " + lineemitters.size + " emitters." );
#/

        for ( i = 0; i < lineemitters.size; i++ )
        {
            lineemitters[i] thread soundlinethink();
            delay = delay + 1;

            if ( delay % 20 == 0 )
                wait 0.01;
        }
    }
    else
    {
/#
        if ( getdvarint( #"debug_audio" ) > 0 )
            println( "*** Client : No line emitter sounds." );
#/
    }
}

init_audio_triggers( localclientnum )
{
    waitforclient( localclientnum );
    steptrigs = getentarray( localclientnum, "audio_step_trigger", "targetname" );
    materialtrigs = getentarray( localclientnum, "audio_material_trigger", "targetname" );
/#
    if ( getdvarint( #"debug_audio" ) > 0 )
    {
        println( "Client : " + steptrigs.size + " audio_step_triggers." );
        println( "Client : " + materialtrigs.size + " audio_material_triggers." );
    }
#/
    array_thread( steptrigs, ::audio_step_trigger, localclientnum );
    array_thread( materialtrigs, ::audio_material_trigger, localclientnum );
}

audio_step_trigger( localclientnum )
{
    self.localclientnum = localclientnum;

    for (;;)
    {
        self waittill( "trigger", trigplayer );
        self thread trigger_thread( trigplayer, ::trig_enter_audio_step_trigger, ::trig_leave_audio_step_trigger );
    }
}

audio_material_trigger( trig )
{
    for (;;)
    {
        self waittill( "trigger", trigplayer );
        self thread trigger_thread( trigplayer, ::trig_enter_audio_material_trigger, ::trig_leave_audio_material_trigger );
    }
}

trig_enter_audio_material_trigger( player )
{
    if ( !isdefined( player.inmaterialoverridetrigger ) )
        player.inmaterialoverridetrigger = 0;

    if ( isdefined( self.script_label ) )
    {
        player.inmaterialoverridetrigger++;
        player.audiomaterialoverride = self.script_label;
        player setmaterialoverride( self.script_label );
    }
}

trig_leave_audio_material_trigger( player )
{
    if ( isdefined( self.script_label ) )
    {
        player.inmaterialoverridetrigger--;
        assert( player.inmaterialoverridetrigger >= 0 );

        if ( player.inmaterialoverridetrigger <= 0 )
        {
            player.audiomaterialoverride = undefined;
            player.inmaterialoverridetrigger = 0;
            player clearmaterialoverride();
        }
    }
}

trig_enter_audio_step_trigger( trigplayer )
{
    localclientnum = self.localclientnum;

    if ( !isdefined( trigplayer.insteptrigger ) )
        trigplayer.insteptrigger = 0;

    if ( isdefined( self.script_label ) )
    {
        trigplayer.step_sound = self.script_label;
        trigplayer.insteptrigger = trigplayer.insteptrigger + 1;
        trigplayer setsteptriggersound( self.script_label );
    }

    if ( isdefined( self.script_sound ) && trigplayer getmovementtype() == "sprint" )
    {
        volume = get_vol_from_speed( trigplayer );
        trigplayer playsound( localclientnum, self.script_sound, self.origin, volume );
    }
}

trig_leave_audio_step_trigger( trigplayer )
{
    localclientnum = self.localclientnum;

    if ( isdefined( self.script_noteworthy ) && trigplayer getmovementtype() == "sprint" )
    {
        volume = get_vol_from_speed( trigplayer );
        trigplayer playsound( localclientnum, self.script_noteworthy, self.origin, volume );
    }

    if ( isdefined( self.script_label ) )
        trigplayer.insteptrigger = trigplayer.insteptrigger - 1;

    if ( trigplayer.insteptrigger < 0 )
    {
/#
        println( "AUDIO WARNING InStepTrigger less than 0. Should never be. setting to 0" );
#/
        trigplayer.insteptrigger = 0;
    }

    if ( trigplayer.insteptrigger == 0 )
    {
        trigplayer.step_sound = "none";
        trigplayer clearsteptriggersound();
    }
}

bump_trigger_start( localclientnum )
{
    bump_trigs = getentarray( localclientnum, "audio_bump_trigger", "targetname" );

    for ( i = 0; i < bump_trigs.size; i++ )
        bump_trigs[i] thread thread_bump_trigger( localclientnum );
}

thread_bump_trigger( localclientnum )
{
    self thread bump_trigger_listener();

    if ( !isdefined( self.script_activated ) )
        self.script_activated = 1;

    self.localclientnum = localclientnum;

    for (;;)
    {
        self waittill( "trigger", trigplayer );
        self thread trigger_thread( trigplayer, ::trig_enter_bump, ::trig_leave_bump );
    }
}

trig_enter_bump( ent )
{
    localclientnum = self.localclientnum;
    volume = get_vol_from_speed( ent );

    if ( isdefined( self.script_sound ) && self.script_activated )
    {
        if ( isdefined( self.script_noteworthy ) && isdefined( self.script_wait ) && self.script_wait > volume )
            test_id = ent playsound( localclientnum, self.script_noteworthy, self.origin, volume );

        if ( isdefined( self.script_parameters ) )
            test_id = ent playsound( localclientnum, self.script_parameters, self.origin, volume );

        if ( !isdefined( self.script_wait ) || self.script_wait <= volume )
            test_id = ent playsound( localclientnum, self.script_sound, self.origin, volume );
    }
}

trig_leave_bump( ent )
{

}

bump_trigger_listener()
{
    if ( isdefined( self.script_label ) )
    {
        level waittill( self.script_label );
        self.script_activated = 0;
    }
}

scale_speed( x1, x2, y1, y2, z )
{
    if ( z < x1 )
        z = x1;

    if ( z > x2 )
        z = x2;

    dx = x2 - x1;
    n = ( z - x1 ) / dx;
    dy = y2 - y1;
    w = n * dy + y1;
    return w;
}

get_vol_from_speed( player )
{
    min_speed = 21;
    max_speed = 285;
    max_vol = 1;
    min_vol = 0.1;
    speed = player getspeed();

    if ( speed == 0 )
        speed = 175;

    abs_speed = absolute_value( int( speed ) );
    volume = scale_speed( min_speed, max_speed, min_vol, max_vol, abs_speed );
    return volume;
}

absolute_value( fowd )
{
    if ( fowd < 0 )
        return fowd * -1;
    else
        return fowd;
}

closest_point_on_line_to_point( point, linestart, lineend )
{
    self endon( "end line sound" );
    linemagsqrd = lengthsquared( lineend - linestart );
    t = ( ( point[0] - linestart[0] ) * ( lineend[0] - linestart[0] ) + ( point[1] - linestart[1] ) * ( lineend[1] - linestart[1] ) + ( point[2] - linestart[2] ) * ( lineend[2] - linestart[2] ) ) / linemagsqrd;

    if ( t < 0.0 )
        self.origin = linestart;
    else if ( t > 1.0 )
        self.origin = lineend;
    else
    {
        start_x = linestart[0] + t * ( lineend[0] - linestart[0] );
        start_y = linestart[1] + t * ( lineend[1] - linestart[1] );
        start_z = linestart[2] + t * ( lineend[2] - linestart[2] );
        self.origin = ( start_x, start_y, start_z );
    }
}

snd_play_auto_fx( fxid, alias, offsetx, offsety, offsetz, onground, area, threshold, alias_override )
{
    if ( isdefined( level.createfxent ) )
    {
        if ( isdefined( area ) )
        {
            assert( isdefined( threshold ), "must pass in a threshold when area is defined" );
            assert( isdefined( alias_override ), "must pass in alias_override when area is defined" );
        }

        a_fx_id = [];
        a_fx_result_origin = [];

        for ( i = 0; i < level.createfxent.size; i++ )
        {
            if ( level.createfxent[i].v["fxid"] == fxid )
            {
                if ( isdefined( area ) )
                    level.createfxent[i].soundentarea = area;

                a_fx_id[a_fx_id.size] = level.createfxent[i];
            }
        }

        if ( isdefined( area ) )
        {
            for ( i = 0; i < a_fx_id.size; i++ )
            {
                for ( j = i + 1; j < a_fx_id.size; j++ )
                {
                    distance_square = distancesquared( a_fx_id[i].v["origin"], a_fx_id[j].v["origin"] );

                    if ( distance_square < area * area )
                    {
/#
                        if ( getdvarint( #"debug_audio" ) > 0 )
                        {
                            n_dist = distance( a_fx_id[i].v["origin"], a_fx_id[j].v["origin"] );
                            line( a_fx_id[i].v["origin"], a_fx_id[j].v["origin"], ( 1, 1, 1 ), 1, 0, 100000000 );
                            print3d( ( ( a_fx_id[i].v["origin"][0] + a_fx_id[j].v["origin"][0] ) / 2, ( a_fx_id[i].v["origin"][1] + a_fx_id[j].v["origin"][1] ) / 2, 10 ), n_dist, ( 1, 1, 1 ), 1, 1, 1000000000 );
                        }
#/

                        if ( isdefined( a_fx_id[j].adjacent ) && !isdefined( a_fx_id[i].adjacent ) )
                        {
                            a_fx_id[i].adjacent = a_fx_id[j].adjacent;
                            continue;
                        }

                        if ( !isdefined( a_fx_id[i].adjacent ) )
                        {
                            a_fx_id[i].adjacent = i;
                            a_fx_id[j].adjacent = i;
                            continue;
                        }

                        a_fx_id[j].adjacent = a_fx_id[i].adjacent;
                    }
                }

/#
                if ( getdvarint( #"debug_audio" ) > 0 )
                {
                    if ( isdefined( a_fx_id[i].adjacent ) )
                    {
                        print3d( a_fx_id[i].v["origin"], a_fx_id[i].adjacent, ( 1, 1, 1 ), 1, 1, 100000000 );
                        continue;
                    }

                    print3d( a_fx_id[i].v["origin"], "single", ( 1, 1, 1 ), 1, 1, 100000000 );
                }
#/
            }

            size = a_fx_id.size;

            for ( i = 0; i < size; i++ )
            {
                a_temp_array = [];

                if ( !isdefined( a_fx_id[i] ) )
                    continue;

                if ( !isdefined( a_fx_id[i].adjacent ) )
                {
                    n_new_array_index = a_fx_result_origin.size;
                    a_fx_result_origin[n_new_array_index] = a_fx_id[i];
                    a_fx_result_origin[n_new_array_index].origin = a_fx_id[i].v["origin"];
                    a_fx_id[i] = undefined;
                    continue;
                }
                else
                {
                    a_temp_array[a_temp_array.size] = a_fx_id[i];
                    a_fx_id[i] = undefined;
                }

                for ( j = i + 1; j < size; j++ )
                {
                    if ( !isdefined( a_fx_id[j] ) )
                        continue;

                    if ( isdefined( a_fx_id[j].adjacent ) )
                    {
                        if ( a_fx_id[j].adjacent == a_temp_array[a_temp_array.size - 1].adjacent )
                        {
                            a_temp_array[a_temp_array.size] = a_fx_id[j];
                            a_fx_id[j] = undefined;
                        }
                    }
                }

                if ( a_temp_array.size > threshold )
                {
                    x = 0;
                    y = 0;
                    z = 0;

                    for ( k = 0; k < a_temp_array.size; k++ )
                    {
                        x = x + a_temp_array[k].v["origin"][0];
                        y = y + a_temp_array[k].v["origin"][1];
                        z = z + a_temp_array[k].v["origin"][2];
                    }

                    x = x / a_temp_array.size;
                    y = y / a_temp_array.size;
                    z = z / a_temp_array.size;
                    n_new_array_index = a_fx_result_origin.size;
                    a_fx_result_origin[n_new_array_index] = spawnstruct();
                    a_fx_result_origin[n_new_array_index].origin = ( x, y, z );
                    a_fx_result_origin[n_new_array_index].alias_override = 1;
                    continue;
                }

                for ( k = 0; k < a_temp_array.size; k++ )
                {
                    n_new_array_index = a_fx_result_origin.size;
                    a_fx_result_origin[n_new_array_index] = spawnstruct();
                    a_fx_result_origin[n_new_array_index].origin = a_temp_array[k].v["origin"];
                }
            }
        }
        else
        {
            for ( i = 0; i < a_fx_id.size; i++ )
            {
                n_new_array_index = a_fx_result_origin.size;
                a_fx_result_origin[n_new_array_index] = a_fx_id[i];
                a_fx_result_origin[n_new_array_index].origin = a_fx_id[i].v["origin"];
            }
        }

        for ( i = 0; i < a_fx_result_origin.size; i++ )
        {
            v_origin = a_fx_result_origin[i].origin;

            if ( isdefined( offsetx ) && offsetx != 0 )
                v_origin = v_origin + ( offsetx, 0, 0 );

            if ( isdefined( offsety ) && offsety != 0 )
                v_origin = v_origin + ( 0, offsety, 0 );

            if ( isdefined( offsetz ) && offsetz != 0 )
                v_origin = v_origin + ( 0, 0, offsetz );

            if ( isdefined( onground ) && onground )
            {
                trace = undefined;
                d = undefined;
                v_fxorigin = v_origin;
                trace = bullettrace( v_fxorigin, v_fxorigin - vectorscale( ( 0, 0, 1 ), 100000.0 ), 0, undefined );
                d = distance( v_fxorigin, trace["position"] );
                v_origin = trace["position"];
            }

            if ( !isdefined( a_fx_result_origin[i].alias_override ) )
            {
                soundloopemitter( alias, v_origin );
                continue;
            }

            soundloopemitter( alias_override, v_origin );
        }
    }
    else
    {
/#
        println( "^5 ******* NO FX IN LEVEL" );
#/
    }
}

snd_print_fx_id( fxid, type, ent )
{
/#
    if ( getdvarint( #"debug_audio" ) > 0 )
        println( "^5 ******* fxid; " + fxid + "^5 type; " + type );
#/
}

debug_line_emitter()
{
    while ( true )
    {
/#
        if ( getdvarint( #"debug_audio" ) > 0 )
        {
            line( self.start, self.end, ( 0, 1, 0 ) );
            print3d( self.start, "START", vectorscale( ( 0, 1, 0 ), 0.8 ), 1, 3, 1 );
            print3d( self.end, "END", vectorscale( ( 0, 1, 0 ), 0.8 ), 1, 3, 1 );
            print3d( self.origin, self.script_sound, vectorscale( ( 0, 1, 0 ), 0.8 ), 1, 3, 1 );
        }

        wait 0.01;
#/
    }
}

move_sound_along_line()
{
    closest_dist = undefined;
/#
    self thread debug_line_emitter();
#/

    while ( true )
    {
        self closest_point_on_line_to_point( getlocalclientpos( 0 ), self.start, self.end );

        if ( isdefined( self.fake_ent ) )
            setfakeentorg( self.localclientnum, self.fake_ent, self.origin );

        closest_dist = distancesquared( getlocalclientpos( 0 ), self.origin );

        if ( closest_dist > 1048576 )
            wait 2;
        else if ( closest_dist > 262144 )
            wait 0.2;
        else
            wait 0.05;
    }
}

line_sound_player()
{
    if ( isdefined( self.script_looping ) )
    {
        self.fake_ent = spawnfakeent( self.localclientnum );
        setfakeentorg( self.localclientnum, self.fake_ent, self.origin );
        playloopsound( self.localclientnum, self.fake_ent, self.script_sound );
    }
    else
        playsound( self.localclientnum, self.script_sound, self.origin );
}

playloopat( aliasname, origin )
{
    soundloopemitter( aliasname, origin );
}

stoploopat( aliasname, origin )
{
    soundstoploopemitter( aliasname, origin );
}

soundwait( id )
{
    while ( soundplaying( id ) )
        wait 0.1;
}

snd_final_killcam()
{
    while ( true )
    {
        level waittill( "fkcb" );
        playsound( 0, "mpl_final_kill_cam_sting" );
        activateambientroom( 0, "final_kill_cam", 10 );
        level waittill( "fkce" );
        wait 0.01;
        deactivateambientroom( 0, "final_kill_cam", 10 );
    }
}

snd_killstreak_reaper()
{
    while ( true )
    {
        level waittill( "krms" );
        level thread waitfor_reaper_end();
        snd_set_snapshot( "mpl_ks_reaper" );
        soundloopemitter( "mpl_ks_reaper_interior_loop", ( 0, 0, 0 ) );
    }
}

waitfor_reaper_end()
{
    level waittill( "krme" );
    snd_set_snapshot( "default" );
    soundstoploopemitter( "mpl_ks_reaper_interior_loop", ( 0, 0, 0 ) );
}

emp_static()
{
    while ( true )
    {
        level waittill( "empo" );
        playsound( 0, "wpn_emp_bomb_static_start" );
        wait 0.7;
        soundloopemitter( "wpn_emp_bomb_static_loop", ( 0, 0, 0 ) );
        level waittill( "empx" );
        playsound( 0, "wpn_emp_bomb_static_stop" );
        soundstoploopemitter( "wpn_emp_bomb_static_loop", ( 0, 0, 0 ) );
    }
}

global_futz_watcher()
{
    while ( true )
    {
        msg = level waittill_any_return( "agrfutz", "reapfutz", "qrfutz", "rcfutz", "cgfutz", "nofutz" );

        switch ( msg )
        {
            case "agrfutz":
                break;
            case "reapfutz":
                break;
            case "qrfutz":
                break;
            case "rcfutz":
                break;
            case "cgfutz":
                break;
            default:
                setglobalfutz( "no_gfutz", 0.0 );
                break;
        }
    }
}

rpgwhizbywatcher( rpg )
{
    self endon( "entityshutdown" );
    self endon( "death" );
    wait 0.2;
    self thread projectilewhizbydistancecheck( self, "wpn_rpg_whizby", 300 );
}

projectilewhizbydistancecheck( projectile, alais, distance )
{
    self endon( "entityshutdown" );
    self endon( "death" );
    players = level.localplayers;

    while ( isdefined( projectile ) && isdefined( projectile.origin ) )
    {
        if ( isdefined( players[0] ) && isdefined( players[0].origin ) )
        {
            projectiledistance = distancesquared( projectile.origin, players[0].origin );

            if ( projectiledistance <= distance * distance )
            {
                projectile playsound( 0, alais );
                return;
            }
        }

        wait 0.2;
    }
}

post_match_snapshot()
{
    level waittill( "pm" );
    snd_set_snapshot( "mpl_post_match" );
    level waittill( "pmf" );
    wait 2.5;
    snd_set_snapshot( "mpl_post_match_full" );
}

soundplayuidecodeloop( decodestring, playtimems )
{
    if ( !isdefined( level.playinguidecodeloop ) || !level.playinguidecodeloop )
    {
        level.playinguidecodeloop = 1;
        fake_ent = spawn( 0, ( 0, 0, 0 ), "script_origin" );

        if ( isdefined( fake_ent ) )
        {
            fake_ent playloopsound( "uin_notify_data_loop" );
            wait( playtimems / 1000 );
            fake_ent stoploopsound();
        }

        level.playinguidecodeloop = undefined;
    }
}
