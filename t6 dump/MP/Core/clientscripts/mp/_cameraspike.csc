// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;
#include clientscripts\mp\_fx;

init()
{
    level._effect["cameraspike_enemy_light"] = loadfx( "misc/fx_equip_light_red" );
    level._effect["cameraspike_friendly_light"] = loadfx( "misc/fx_equip_light_green" );
    level._client_flag_callbacks["scriptmover"][10] = ::spawned;

    if ( !isdefined( level.cameraspikes ) )
        level.cameraspikes = [];

    if ( !isdefined( level.cameraspikeactive ) )
        level.cameraspikeactive = [];

    if ( !isdefined( level.cameraspikehandle ) )
        level.cameraspikehandle = 0;

    level thread updatecameraspikes();
}

resetcameraspikestate( localclientnum )
{
    setcameraspikeactive( localclientnum, 0 );
    animatecameramenus( localclientnum, "Default", 0 );
    level notify( "activateCameraStatic" );
    setextracamstatic( localclientnum, 0 );
}

playerspawned()
{
    self endon( "entityshutdown" );

    while ( true )
    {
        localplayers = level.localplayers;

        for ( i = 0; i < localplayers.size; i++ )
        {
            if ( localplayers[i] == self )
                self resetcameraspikestate( i );
        }

        self waittill( "respawn" );
    }
}

setcameraspikeactive( localclientnum, active )
{
    if ( !isdefined( level.cameraspikeactive[localclientnum] ) )
        level.cameraspikeactive[localclientnum] = 0;

    wasactive = level.cameraspikeactive[localclientnum];
    level.cameraspikeactive[localclientnum] = active;
    staticseconds = 0.25;

    if ( active != wasactive )
    {
        if ( active )
        {
            animatecameramenus( localclientnum, "spike_cam_on", int( staticseconds * 1000 ) );
            playsound( 0, "fly_camera_on", ( 0, 0, 0 ) );
        }
        else
        {
            animatecameramenus( localclientnum, "Default", int( staticseconds * 1000 ) );
            playsound( 0, "fly_camera_off", ( 0, 0, 0 ) );
        }

        activatecamerastatic( localclientnum, staticseconds );
    }

    setextracamactive( localclientnum, active > 0 );
}

animatecameramenus( localclientnum, statename, duration )
{
    if ( getactivelocalclients() > 1 )
        return;

    animateui( localclientnum, "spike_cam", "*", statename, duration );
    animateui( localclientnum, "class", "*", statename, duration );
    animateui( localclientnum, "talkers", "*", statename, duration );
}

addcameraspike( handle, cameraent )
{
    cameraspike = spawnstruct();
    cameraspike.handle = handle;
    cameraspike.cameraent = cameraent;
    size = level.cameraspikes.size;
    level.cameraspikes[size] = cameraspike;
}

removecameraspike( cameraspikehandle )
{
    for ( i = 0; i < level.cameraspikes.size; i++ )
    {
        last = level.cameraspikes.size - 1;

        if ( level.cameraspikes[i].handle == cameraspikehandle )
        {
            level.cameraspikes[i].handle = level.cameraspikes[last].handle;
            level.cameraspikes[i].cameraent = level.cameraspikes[last].cameraent;
            level.cameraspikes[last] = undefined;
        }
    }
}

spawned( localclientnum, set )
{
    if ( !set || !issplitscreenhost( localclientnum ) )
        return;

    handle = level.cameraspikehandle;
    level.cameraspikehandle++;
    self thread watchshutdown( handle );
    self endon( "entityshutdown" );
    addcameraspike( handle, self );
    self thread clientscripts\mp\_fx::blinky_light( localclientnum, "tag_light", level._effect["cameraspike_friendly_light"], level._effect["cameraspike_enemy_light"] );
}

watchshutdown( handle )
{
    self waittill( "entityshutdown" );
    removecameraspike( handle );
}

updatecameraspikes()
{
    self endon( "entityshutdown" );
    cameraspikeenabled = [];
    cameraspikecountprevious = -1;
    waitforclient( 0 );

    while ( true )
    {
        localplayers = level.localplayers;

        if ( level.cameraspikes.size != 0 || cameraspikecountprevious != 0 )
        {
            for ( i = 0; i < localplayers.size; i++ )
            {
                cameraspikeenabled[i] = 0;
                setextracamentity( i, undefined );
            }

            for ( i = 0; i < level.cameraspikes.size; i++ )
            {
                for ( j = 0; j < localplayers.size; j++ )
                {
                    if ( localplayers[j] == level.cameraspikes[i].cameraent getowner( j ) )
                    {
                        setextracamentity( j, level.cameraspikes[i].cameraent );

                        if ( iscameraspiketoggled( j ) )
                        {
                            cameraspikeenabled[j] = 1;
                            setextracamorigin( j, level.cameraspikes[i].cameraent gettagorigin( "tag_cam" ) );
                            setextracamangles( j, level.cameraspikes[i].cameraent.angles );

                            if ( isdefined( level.cameraspikes[i].cameraent.stunned ) && level.cameraspikes[i].cameraent.stunned )
                                activatecamerastatic( j, 0.25 );
                        }
                    }
                }
            }

            for ( i = 0; i < localplayers.size; i++ )
                setcameraspikeactive( i, cameraspikeenabled[i] );
        }

        cameraspikecountprevious = level.cameraspikes.size;
        wait 0.01;
    }
}

activatecamerastatic( localclientnum, seconds )
{
    setextracamstatic( localclientnum, 1 );
    level thread activatecamerastaticwaiter( localclientnum, seconds );
}

activatecamerastaticwaiter( localclientnum, seconds )
{
    self endon( "entityshutdown" );
    self notify( "activateCameraStatic" );
    self endon( "activateCameraStatic" );
    waitrealtime( seconds );
    setextracamstatic( localclientnum, 0 );
}
