// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_utility_code;
#include clientscripts\mp\_vehicle;
#include clientscripts\mp\_rewindobjects;

planesounds( localclientnum, spawnsound, flybysound, flybysoundloop )
{
    self endon( "delete" );
    fake_ent_plane = spawnfakeent( 0 );

    if ( !isdefined( fake_ent_plane ) )
        return;

    playsound( 0, spawnsound, ( 0, 0, 0 ) );
    thread plane_position_updater( localclientnum, fake_ent_plane, self, flybysound, flybysoundloop );
}

plane_position_updater( localclientnum, fake_ent, plane, flybysound, flybysoundloop )
{
    soundid = -1;
    dx = undefined;
    lasttime = undefined;
    lastpos = undefined;
    starttime = 0;

    while ( isdefined( plane ) )
    {
        setfakeentorg( 0, fake_ent, plane.origin );

        if ( soundid < 0 && isdefined( lastpos ) )
        {
            dx = plane.origin - lastpos;

            if ( length( dx ) > 0.01 )
            {
                velocity = dx / ( getrealtime() - lasttime );
                assert( isdefined( velocity ) );
                players = level.localplayers;
                assert( isdefined( players ) );
                other_point = plane.origin + velocity * 100000;
                point = closest_point_on_line_to_point( players[0].origin, plane.origin, other_point );
                assert( isdefined( point ) );
                dist = distance( point, plane.origin );
                assert( isdefined( dist ) );
                time = dist / length( velocity );
                assert( isdefined( time ) );

                if ( isdefined( flybysoundloop ) && isdefined( fake_ent ) )
                    soundid = playloopsound( 0, fake_ent, flybysoundloop, 0 );

                if ( isdefined( flybysound ) )
                    plane playsound( 0, flybysound );

                starttime = getrealtime();
            }
        }

        lastpos = plane.origin;
        lasttime = getrealtime();
        wait 0.1;
    }

    serverwait( localclientnum, 5 );
    deletefakeent( 0, fake_ent );
}

closest_point_on_line_to_point( point, linestart, lineend )
{
    linemagsqrd = lengthsquared( lineend - linestart );
    t = ( ( point[0] - linestart[0] ) * ( lineend[0] - linestart[0] ) + ( point[1] - linestart[1] ) * ( lineend[1] - linestart[1] ) + ( point[2] - linestart[2] ) * ( lineend[2] - linestart[2] ) ) / linemagsqrd;

    if ( t < 0.0 )
        return linestart;
    else if ( t > 1.0 )
        return lineend;
    else
    {
        start_x = linestart[0] + t * ( lineend[0] - linestart[0] );
        start_y = linestart[1] + t * ( lineend[1] - linestart[1] );
        start_z = linestart[2] + t * ( lineend[2] - linestart[2] );
        return ( start_x, start_y, start_z );
    }
}

getplanemodel( teamfaction )
{
    planemodel = "t5_veh_jet_f4_gearup";
    return planemodel;
}

planeturnright( localclientnum, plane, yaw, halflife, starttime )
{
    planeturn( localclientnum, plane, yaw, halflife, starttime, 1 );
}

planeturnleft( localclientnum, plane, yaw, halflife, starttime )
{
    planeturn( localclientnum, plane, yaw, halflife, starttime, 0 );
}

planeturn( localclientnum, plane, yaw, halflife, starttime, isturningright )
{
    plane endon( "delete" );
    plane endon( "entityshutdown" );
    level endon( "demo_jump" + localclientnum );
    leftturn = -1;
    rightturn = 1;

    if ( isturningright )
        turndirection = rightturn;
    else
        turndirection = leftturn;

    yawy = getdvarfloatdefault( "scr_planeyaw", -1.5 * turndirection );
    rollz = getdvarfloatdefault( "scr_planeroll", 1.5 * turndirection );
    maxyaw = getdvarfloatdefault( "scr_max_planeyaw", -45.0 * turndirection );
    minroll = getdvarfloatdefault( "scr_min_planeroll", 60.0 * turndirection );
    ox = getdvarfloatdefault( "scr_planeox", 30000.0 );
    oy = getdvarfloatdefault( "scr_planeoy", -30000.0 * turndirection );
    maxox = getdvarfloatdefault( "scr_maxo_planex", -1.0 );
    maxoy = getdvarfloatdefault( "scr_maxo_planey", -1.0 );

    if ( plane.angles[1] == 360 )
        plane.angles = ( plane.angles[0], 0, plane.angles[2] );

    origx = plane.origin[0];
    origy = plane.origin[1];
    accumturn = 0;
    looptime = 0.1;
    waitamount = 0.1;
    waitformovedone = 0;

    while ( looptime <= halflife )
    {
        if ( plane.angles[1] == 360 )
            plane.angles = ( plane.angles[0], 0, plane.angles[2] );

        if ( minroll != -1 && plane.angles[2] >= minroll * turndirection )
            rollz = 0.0;

        accumturn = accumturn + yawy;

        if ( accumturn <= maxyaw * turndirection )
            yawy = 0.0;

        angles = ( plane.angles[0], plane.angles[1] + yawy, plane.angles[2] + rollz );
        mathx = sin( 45 * looptime / halflife ) * ox;
        mathy = cos( 45 * looptime / halflife ) * oy;
        oldx = mathx;
        oldy = oy - mathy;
        rotatedx = cos( yaw ) * oldx - sin( yaw ) * oldy;
        rotatedy = sin( yaw ) * oldx + cos( yaw ) * oldy;
        endpoint = ( origx + rotatedx, origy + rotatedy, plane.origin[2] );

        if ( waitformovedone )
            plane waittill( "movedone" );

        waitformovedone = plane servertimedmoveto( localclientnum, plane.origin, endpoint, starttime, waitamount );
        plane servertimedrotateto( localclientnum, angles, starttime, waitamount );
        looptime = looptime + waitamount;
        starttime = starttime + waitamount * 1000;
    }

    yawy = getdvarfloatdefault( "scr_planeyaw2", 1.5 );
    rollz = getdvarfloatdefault( "scr_planeroll2", -0.9 );
    ox = getdvarfloatdefault( "scr_planeox", 30000.0 );
    oy = getdvarfloatdefault( "scr_planeoy", -30000.0 * turndirection );
    maxox = getdvarfloatdefault( "scr_maxo_planex", -1.0 );
    maxoy = getdvarfloatdefault( "scr_maxo_planey", -1.0 );
    y = getdvarfloatdefault( "scr_planey2", 0.6 );
    z = getdvarfloatdefault( "scr_planez2", -1.5 );
    maxy = getdvarfloatdefault( "scr_max_planey2", 90 );
    accumturn = 0;

    while ( looptime < halflife + halflife )
    {
        if ( plane.angles[1] == 360 )
            plane.angles = ( plane.angles[0], 0, plane.angles[2] );

        if ( minroll != -1 && plane.angles[2] >= 0 )
            rollz = 0.0;

        accumturn = accumturn + yawy;

        if ( accumturn >= maxyaw )
            yawy = 0.0;

        angles = ( plane.angles[0], plane.angles[1] + yawy, plane.angles[2] - rollz );
        mathx = sin( 45 * looptime / halflife ) * ox;
        mathy = cos( 45 * looptime / halflife ) * oy;
        oldx = mathx;
        oldy = oy - mathy;
        rotatedx = cos( yaw ) * oldx - sin( yaw ) * oldy;
        rotatedy = sin( yaw ) * oldx + cos( yaw ) * oldy;
        endpoint = ( origx + rotatedx, origy + rotatedy, plane.origin[2] );

        if ( waitformovedone )
            plane waittill( "movedone" );

        waitformovedone = plane servertimedmoveto( localclientnum, plane.origin, endpoint, starttime, waitamount );
        plane servertimedrotateto( localclientnum, angles, starttime, waitamount );
        looptime = looptime + waitamount;
        starttime = starttime + waitamount * 1000;
    }
}

doabarrelroll( localclientnum, plane, endpoint, flytime, starttime )
{
    plane endon( "entityshutdown" );
    plane endon( "delete" );
    level endon( "demo_jump" );
    origin = plane.origin;
    originalheight = origin[2];
    loopwaittime = getdvarfloatdefault( "scr_loopwaittime", 0.5 );
    loopheightrand = getdvarfloatdefault( "scr_loopheightrand", 500 );
    loopheight = getdvarfloatdefault( "scr_loopheight", 1200 );
    rollz = getdvarfloatdefault( "scr_barrelroll", 10 );
    degreestoroll = getdvarfloatdefault( "scr_degreesToRoll", 360 );
    unitsfromcentrepoint = 100;
    timeelapsed = 0;
    degreesrolled = 0;
    waitamount = 0.1;
    loopheight = loopheight + randomfloatrange( 0 - loopheightrand, loopheightrand );
    waitformovedone = 0;
    angles = plane.angles;
    originalroll = plane.angles[2];

    while ( timeelapsed < flytime )
    {
        timeelapsed = timeelapsed + waitamount;

        if ( timeelapsed > loopwaittime && degreesrolled < degreestoroll )
        {
            pitch = degreesrolled / 8;

            if ( pitch > 22.5 )
                pitch = 45 - pitch;

            originalangle = plane.angles[2];
            scr_degreestoroll = getdvarintdefault( "scr_degreesToRoll", 0 );

            if ( scr_degreestoroll )
                plane.angles[1] = 0;

            angles = ( 0 - pitch, plane.angles[1], originalroll + degreesrolled );
            degreesrolled = degreesrolled + rollz;
        }

        ratio = timeelapsed / ( flytime / 2 );
        nextpoint = getpointonline( origin, endpoint, ratio );
        nextheight = originalheight + ( loopheight - cos( degreesrolled / 2 ) * loopheight );
        nextpoint = ( nextpoint[0], nextpoint[1], nextheight );

        if ( waitformovedone )
            plane waittill( "movedone" );

        waitformovedone = plane servertimedmoveto( localclientnum, plane.origin, nextpoint, starttime, waitamount );
        plane servertimedrotateto( localclientnum, angles, starttime, waitamount );
        starttime = starttime + waitamount * 1000;
    }
}

planegostraight( localclientnum, plane, startpoint, endpoint, movetime, starttime )
{
    plane endon( "delete" );
    level endon( "demo_jump" );
    distanceincreaseratio = 2;
    destpoint = getpointonline( startpoint, endpoint, distanceincreaseratio );

    if ( plane servertimedmoveto( localclientnum, startpoint, destpoint, starttime, movetime ) )
        plane waittill( "movedone" );
}
