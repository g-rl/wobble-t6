// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;

init()
{
    init_maze_clientfields();
    level._maze_structs = getstructarray( "maze_blocker", "targetname" );
}

init_maze_clientfields()
{
    blocker_locations = getstructarray( "maze_blocker", "targetname" );
    level._maze_structs_indexed_for_callback = [];

    foreach ( blocker in blocker_locations )
    {
        registerclientfield( "world", "maze_blocker_" + blocker.script_noteworthy, 12000, 1, "int", ::maze_effects, 0 );
        level._maze_structs_indexed_for_callback["maze_blocker_" + blocker.script_noteworthy] = blocker;
    }
}

maze_effects_thread( localclientnum, fieldname )
{
    self endon( "kill_maze_effects_thread" );
    struct = level._maze_structs_indexed_for_callback[fieldname];
    self thread kill_maze_effects_thread( localclientnum, struct );

    if ( !isdefined( struct.loopfx_ids ) )
    {
        struct.loopfx_ids = [];
        struct.angles_to_foward = anglestoforward( struct.angles );
        struct.angles_to_up = anglestoup( struct.angles );
    }
}

kill_maze_effects_thread( localclientnum, struct )
{
    self waittill( "kill_maze_effects_thread" );

    if ( isdefined( struct.loopfx_ids ) && isdefined( struct.loopfx_ids[localclientnum] ) )
    {
        deletefx( localclientnum, struct.loopfx_ids[localclientnum] );
        struct.loopfx_ids[localclientnum] = undefined;
    }
}

maze_effects( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( bwasdemojump )
        self notify( "kill_maze_effects_thread" );

    if ( newval )
        self thread maze_effects_thread( localclientnum, fieldname );
    else
        self notify( "kill_maze_effects_thread" );
}
