// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_fx;
#include clientscripts\mp\_music;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zm_tomb;

init()
{
    if ( getdvar( #"createfx" ) == "on" )
        return;

    level._effect["whirlwind"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_air_ug_impact_miss" );
    registerclientfield( "scriptmover", "whirlwind_play_fx", 14000, 1, "int", ::whirlwind_fx );
    registerclientfield( "actor", "air_staff_launch", 14000, 1, "int", ::air_staff_launch );
    registerclientfield( "allplayers", "air_staff_source", 14000, 1, "int", ::set_air_staff_source );
    level.launch_source = ( 0, 0, 0 );
    level.whirlwind_pos = [];
}

set_air_staff_source( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    level.launch_source = self.origin;
}

ragdoll_impact_watch( localclientnum )
{
    self endon( "entityshutdown" );
    wait 0.1;
    waittime = 0.016;
    gibspeed = 500;
    prevorigin = self.origin;
    waitrealtime( waittime );
    prevvel = self.origin - prevorigin;
    prevspeed = length( prevvel );
    prevorigin = self.origin;
    waitrealtime( waittime );
    firstloop = 1;

    while ( true )
    {
        vel = self.origin - prevorigin;
        speed = length( vel );

        if ( speed < prevspeed * 0.5 && prevspeed > gibspeed * waittime )
        {
            if ( isdefined( level._effect["zombie_guts_explosion"] ) && is_mature() )
            {
                where = self gettagorigin( "J_SpineLower" );
                playfx( localclientnum, level._effect["zombie_guts_explosion"], where );
            }

            break;
        }

        if ( prevspeed < gibspeed * waittime && !firstloop )
            break;

        prevorigin = self.origin;
        prevvel = vel;
        prevspeed = speed;
        firstloop = 0;
        waitrealtime( waittime );
    }
}

air_staff_launch( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    v_source = level.launch_source;
    n_verticality = randomfloatrange( 0.05, 0.35 );
    v_whirlwind = level.whirlwind_pos[localclientnum];

    if ( isdefined( v_whirlwind ) )
    {
        dist_sq = distancesquared( v_whirlwind, self.origin );

        if ( dist_sq < 22500 )
        {
            v_random_offset = ( randomfloatrange( -1000, 1000 ), randomfloatrange( -1000, 1000 ), 0 );
            v_source = v_whirlwind + v_random_offset;
        }
    }

    dir = self.origin - v_source;
    dir = vectornormalize( dir );
    v_force = length( dir ) * 300.0;
    launch = ( dir[0], dir[1], n_verticality );
    launch = vectorscale( launch, v_force );
    self launchragdoll( launch );
    self thread ragdoll_impact_watch( localclientnum );
}

whirlwind_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "entityshutdown" );

    if ( newval )
    {
        self.is_active = 1;
        original_pos = self.origin;
        level.whirlwind_pos[localclientnum] = self.origin;
        level.whirlwind_fx = playfxontag( localclientnum, level._effect["whirlwind"], self, "tag_origin" );

        if ( !isdefined( self.sndent ) )
        {
            self.sndent = spawn( 0, self.origin, "script_origin" );
            self.sndent playloopsound( "wpn_airstaff_tornado", 1 );
            self.sndent thread clientscripts\mp\zm_tomb::snddemojumpmonitor();
        }
    }
    else
    {
        if ( isdefined( level.whirlwind_fx ) )
        {
            self.is_active = 0;
            level.whirlwind_pos[localclientnum] = undefined;
            stopfx( localclientnum, level.whirlwind_fx );
        }

        if ( isdefined( self.sndent ) )
        {
            self.sndent stoploopsound( 1.5 );
            self.sndent delete();
            self.sndent = undefined;
        }
    }
}
