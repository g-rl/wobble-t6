// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_fx;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zombies\_zm_weapons;

#using_animtree("zombie_beacon");

init()
{
    level.beacon_name = "beacon_zm";
    level.beacon_model = "t6_wpn_zmb_homing_beacon_world";

    if ( getdvar( #"createfx" ) == "on" )
        return;

    if ( !clientscripts\mp\zombies\_zm_weapons::is_weapon_included( level.beacon_name ) )
        return;

    level._effect["beacon_glow"] = loadfx( "maps/zombie_tomb/fx_tomb_beacon_glow" );
    level._effect["beacon_launch_fx"] = loadfx( "maps/zombie_tomb/fx_tomb_beacon_launch" );
    level._effect["beacon_shell_explosion"] = loadfx( "maps/zombie_tomb/fx_tomb_beacon_exp" );
    level._effect["beacon_shell_trail"] = loadfx( "maps/zombie_tomb/fx_tomb_beacon_trail" );
    registerclientfield( "world", "play_launch_artillery_fx_robot_0", 14000, 1, "int", ::play_artillery_fx );
    registerclientfield( "world", "play_launch_artillery_fx_robot_1", 14000, 1, "int", ::play_artillery_fx );
    registerclientfield( "world", "play_launch_artillery_fx_robot_2", 14000, 1, "int", ::play_artillery_fx );
    registerclientfield( "scriptmover", "play_beacon_fx", 14000, 1, "int", ::play_beacon_glow );
    registerclientfield( "scriptmover", "play_artillery_barrage", 14000, 2, "int", ::play_artillery_barrage );
    scriptmodelsuseanimtree( #animtree );
}

play_artillery_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( issubstr( fieldname, 0 ) )
        ai_robot = level.a_giant_robots[localclientnum][0];
    else if ( issubstr( fieldname, 1 ) )
        ai_robot = level.a_giant_robots[localclientnum][1];
    else
        ai_robot = level.a_giant_robots[localclientnum][2];

    if ( newval == 1 )
    {
        playfx( localclientnum, level._effect["beacon_launch_fx"], ai_robot gettagorigin( "tag_rocketpod" ) );
        level thread sndfakelaunchaudio( ai_robot gettagorigin( "tag_rocketpod" ) );
    }
}

sndfakelaunchaudio( origin )
{
    playsound( 0, "zmb_homingbeacon_missiile_alarm", origin );

    for ( i = 0; i < 5; i++ )
    {
        playsound( 0, "zmb_homingbeacon_missile_fire", origin );
        wait 0.15;
    }
}

play_beacon_glow( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "weapon_beacon_destroyed" );

    while ( isdefined( self ) )
    {
        playsound( 0, "evt_beacon_beep", self.origin );
        playfxontag( localclientnum, level._effect["beacon_glow"], self, "origin_animate_jnt" );
        wait 1.5;
    }
}

play_artillery_barrage( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 0 )
        return;

    if ( newval == 1 )
    {
        if ( !isdefined( self.a_v_land_offsets ) )
            self.a_v_land_offsets = [];

        if ( !isdefined( self.a_v_land_offsets[localclientnum] ) )
            self.a_v_land_offsets[localclientnum] = self build_weap_beacon_landing_offsets();

        if ( !isdefined( self.a_v_start_offsets ) )
            self.a_v_start_offsets = [];

        if ( !isdefined( self.a_v_start_offsets[localclientnum] ) )
            self.a_v_start_offsets[localclientnum] = self build_weap_beacon_start_offsets();
    }

    if ( newval == 2 )
    {
        if ( !isdefined( self.a_v_land_offsets ) )
            self.a_v_land_offsets = [];

        if ( !isdefined( self.a_v_land_offsets[localclientnum] ) )
            self.a_v_land_offsets[localclientnum] = self build_weap_beacon_landing_offsets_ee();

        if ( !isdefined( self.a_v_start_offsets ) )
            self.a_v_start_offsets = [];

        if ( !isdefined( self.a_v_start_offsets[localclientnum] ) )
            self.a_v_start_offsets[localclientnum] = self build_weap_beacon_start_offsets_ee();
    }

    if ( !isdefined( self.num_rockets_fired ) )
        self.num_rockets_fired = [];

    if ( !isdefined( self.num_rockets_fired[localclientnum] ) )
        self.num_rockets_fired[localclientnum] = 0;

    n_index = self.num_rockets_fired[localclientnum];
    v_start = self.origin + self.a_v_start_offsets[localclientnum][n_index];
    shell = spawn( localclientnum, v_start, "script_model" );
    shell.angles = vectorscale( ( -1, 0, 0 ), 90.0 );
    shell setmodel( "jun_missile" );
    shell thread shell_logic( self, n_index, v_start, localclientnum );
    self.num_rockets_fired[localclientnum]++;
}

build_weap_beacon_landing_offsets()
{
    a_offsets = [];
    a_offsets[0] = ( 0, 0, 0 );
    a_offsets[1] = vectorscale( ( -1, 1, 0 ), 72.0 );
    a_offsets[2] = vectorscale( ( 1, 1, 0 ), 72.0 );
    a_offsets[3] = vectorscale( ( 1, -1, 0 ), 72.0 );
    a_offsets[4] = vectorscale( ( -1, -1, 0 ), 72.0 );
    return a_offsets;
}

build_weap_beacon_start_offsets()
{
    a_offsets = [];
    a_offsets[0] = vectorscale( ( 0, 0, 1 ), 8500.0 );
    a_offsets[1] = ( -6500, 6500, 8500 );
    a_offsets[2] = ( 6500, 6500, 8500 );
    a_offsets[3] = ( 6500, -6500, 8500 );
    a_offsets[4] = ( -6500, -6500, 8500 );
    return a_offsets;
}

build_weap_beacon_landing_offsets_ee()
{
    a_offsets = [];
    a_offsets[0] = ( 0, 0, 0 );
    a_offsets[1] = vectorscale( ( -1, 1, 0 ), 72.0 );
    a_offsets[2] = vectorscale( ( 1, 1, 0 ), 72.0 );
    a_offsets[3] = vectorscale( ( 1, -1, 0 ), 72.0 );
    a_offsets[4] = vectorscale( ( -1, -1, 0 ), 72.0 );
    a_offsets[5] = vectorscale( ( -1, 1, 0 ), 72.0 );
    a_offsets[6] = vectorscale( ( 1, 1, 0 ), 72.0 );
    a_offsets[7] = vectorscale( ( 1, -1, 0 ), 72.0 );
    a_offsets[8] = vectorscale( ( -1, -1, 0 ), 72.0 );
    a_offsets[9] = vectorscale( ( -1, 1, 0 ), 72.0 );
    a_offsets[10] = vectorscale( ( 1, 1, 0 ), 72.0 );
    a_offsets[11] = vectorscale( ( 1, -1, 0 ), 72.0 );
    a_offsets[12] = vectorscale( ( -1, -1, 0 ), 72.0 );
    a_offsets[13] = vectorscale( ( -1, 1, 0 ), 72.0 );
    a_offsets[14] = vectorscale( ( 1, 1, 0 ), 72.0 );
    return a_offsets;
}

build_weap_beacon_start_offsets_ee()
{
    a_offsets = [];
    a_offsets[0] = vectorscale( ( 0, 0, 1 ), 8500.0 );
    a_offsets[1] = ( -6500, 6500, 8500 );
    a_offsets[2] = ( 6500, 6500, 8500 );
    a_offsets[3] = ( 6500, -6500, 8500 );
    a_offsets[4] = ( -6500, -6500, 8500 );
    a_offsets[5] = ( -6500, 6500, 8500 );
    a_offsets[6] = ( 6500, 6500, 8500 );
    a_offsets[7] = ( 6500, -6500, 8500 );
    a_offsets[8] = ( -6500, -6500, 8500 );
    a_offsets[9] = ( -6500, 6500, 8500 );
    a_offsets[10] = ( 6500, 6500, 8500 );
    a_offsets[11] = ( 6500, -6500, 8500 );
    a_offsets[12] = ( -6500, -6500, 8500 );
    a_offsets[13] = ( -6500, 6500, 8500 );
    a_offsets[14] = ( 6500, 6500, 8500 );
    return a_offsets;
}

shell_logic( model, index, v_start, localclientnum )
{
    v_land = model.origin + model.a_v_land_offsets[localclientnum][index];
    v_start_trace = v_start - vectorscale( ( 0, 0, 1 ), 5000.0 );
    trace = bullettrace( v_start_trace, v_land, 0, undefined );
    v_land = trace["position"];
    self moveto( v_land, 3 );
    playfxontag( localclientnum, level._effect["beacon_shell_trail"], self, "tag_origin" );
    self playsound( 0, "zmb_homingbeacon_missile_boom" );
    self thread sndplayincoming( v_land );
    self waittill( "movedone" );

    if ( index == 1 )
        model notify( "weapon_beacon_destroyed" );

    playfx( localclientnum, level._effect["beacon_shell_explosion"], self.origin );
    playsound( 0, "zmb_homingbeacon_missile_impact", self.origin );
    self delete();
}

sndplayincoming( origin )
{
    wait 2;
    playsound( 0, "zmb_homingbeacon_missile_incoming", origin );
}
