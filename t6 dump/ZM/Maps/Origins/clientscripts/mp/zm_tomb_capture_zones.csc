// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\_audio;
#include clientscripts\mp\zombies\_zm;
#include clientscripts\mp\_fx;

init_structs()
{
    precacherumble( "generator_active" );
    level.zombie_custom_riser_fx_handler = ::capture_zombie_riser_fx;
    registerclientfield( "world", "packapunch_anim", 14000, 3, "int", ::play_pap_anim, 0 );
    registerclientfield( "actor", "zone_capture_zombie", 14000, 1, "int", ::zone_capture_zombie_callback );
    registerclientfield( "scriptmover", "zone_capture_emergence_hole", 14000, 1, "int", ::emergence_hole_callback, 0, 0 );
    registerclientfield( "world", "zc_change_progress_bar_color", 14000, 1, "int", undefined, 0 );
    setupclientfieldcodecallbacks( "world", 1, "zc_change_progress_bar_color" );
    registerclientfield( "world", "zone_capture_hud_all_generators_captured", 14000, 1, "int", ::pap_monolith_ring_callback, 0, 1 );
    setupclientfieldcodecallbacks( "world", 1, "zone_capture_hud_all_generators_captured" );
    registerclientfield( "world", "pap_monolith_ring_shake", 14000, 1, "int", ::pap_monolith_ring_shake );
    registerclientfield( "world", "zone_capture_perk_machine_smoke_fx_always_on", 14000, 1, "int", ::perk_machine_smoke_fx_always_on_callback );
    a_s_generator = getstructarray( "s_generator", "targetname" );

    foreach ( struct in a_s_generator )
    {
        registerclientfield( "world", struct.script_noteworthy, 14000, 7, "float", ::set_generator_capture_progress, 0 );
        registerclientfield( "world", "state_" + struct.script_noteworthy, 14000, 3, "int", ::set_generator_state, 0 );
        registerclientfield( "world", "zone_capture_hud_generator_" + struct.script_int, 14000, 2, "int", undefined, 0 );
        registerclientfield( "world", "zone_capture_monolith_crystal_" + struct.script_int, 14000, 1, "int", ::monolith_crysal_glow, 0 );
        registerclientfield( "world", "zone_capture_perk_machine_smoke_fx_" + struct.script_int, 14000, 1, "int", ::perk_machine_smoke_fx_callback, 0 );
        setupclientfieldcodecallbacks( "world", 1, "zone_capture_hud_generator_" + struct.script_int );
    }

    level._effect["zone_capture_damage_spark"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_dmg_armor" );
    level._effect["zone_capture_damage_steam"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_foot_step_steam" );
    level._effect["zone_capture_zombie_spawn"] = loadfx( "maps/zombie_tomb/fx_tomb_emergence_spawn" );
    register_perk_machine_smoke_struct_references();
    register_pack_a_punch_anim_sequence();
    register_exploders_with_capture_zones();
}

#using_animtree("fxanim_props_dlc4");

init_cz_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

set_generator_capture_progress( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_generator = get_generator_entity( fieldname, localclientnum );
    m_generator generator_set_progress( localclientnum, oldval, newval );
}

clear_fluid_column_anims()
{
    self clearanim( %fxanim_zom_tomb_generator_fluid_up_anim, 0 );
    self clearanim( %fxanim_zom_tomb_generator_fluid_down_anim, 0 );
}

clear_pump_anims( b_skip_blend )
{
    if ( !isdefined( b_skip_blend ) )
        b_skip_blend = 0;

    n_blend_time = 0.2;

    if ( b_skip_blend )
        n_blend_time = 0;

    self clearanim( %fxanim_zom_tomb_generator_start_anim, n_blend_time );
    self clearanim( %fxanim_zom_tomb_generator_up_idle_anim, n_blend_time );
    self clearanim( %fxanim_zom_tomb_generator_down_idle_anim, n_blend_time );
    self clearanim( %fxanim_zom_tomb_generator_end_anim, n_blend_time );
}

generator_set_progress( localclientnumber, oldval, newval )
{
    if ( newval == 1 )
    {
        self clearanim( %fxanim_zom_tomb_generator_fluid_rotate_down_anim, 0.2 );
        self setanim( %fxanim_zom_tomb_generator_fluid_rotate_up_anim, 1, 0.2, 1 );
    }
    else if ( newval < oldval && oldval == 1 )
    {
        self clearanim( %fxanim_zom_tomb_generator_fluid_rotate_up_anim, 0.2 );
        self setanim( %fxanim_zom_tomb_generator_fluid_rotate_down_anim, 1, 0.2, 1 );
        wait( getanimlength( %fxanim_zom_tomb_generator_fluid_rotate_down_anim ) );
        self clearanim( %fxanim_zom_tomb_generator_fluid_rotate_down_anim, 0.2 );
    }

    self set_fluid_height( newval );
}

set_fluid_height( newval, b_skip_blend )
{
    if ( !isdefined( b_skip_blend ) )
        b_skip_blend = 0;

    n_blend_time = 0.2;

    if ( b_skip_blend )
        n_blend_time = 0;

    self setanim( %fxanim_zom_tomb_generator_fluid_up_anim, newval, n_blend_time, 1 );
    self setanim( %fxanim_zom_tomb_generator_fluid_down_anim, 1 - newval, n_blend_time, 1 );
    self generator_sound_enable( newval );
}

get_generator_entity( str_name, localclientnumber )
{
    if ( !isdefined( level.zone_capture_generators ) )
        level.zone_capture_generators = [];

    if ( !isdefined( level.zone_capture_generators[localclientnumber] ) )
        level.zone_capture_generators[localclientnumber] = [];

    if ( !isdefined( level.zone_capture_generators[localclientnumber][str_name] ) )
        level.zone_capture_generators[localclientnumber][str_name] = getent( localclientnumber, str_name, "targetname" );

    assert( isdefined( level.zone_capture_generators[localclientnumber][str_name] ), "generator with name " + str_name + " is missing in level.zone_capture_generators array!" );
    level.zone_capture_generators[localclientnumber][str_name] waittill_dobj( localclientnumber );

    if ( !level.zone_capture_generators[localclientnumber][str_name] hasanimtree() )
        level.zone_capture_generators[localclientnumber][str_name] useanimtree( #animtree );

    return level.zone_capture_generators[localclientnumber][str_name];
}

set_generator_state( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_generator = get_generator_entity( getsubstr( fieldname, 6 ), localclientnum );
    n_blend_time = 0.2;

    if ( bnewent || binitialsnap || bwasdemojump )
        n_blend_time = 0;

    m_generator clear_pump_anims();
    m_generator notify( "generator_state_changed" );

    if ( newval != 0 )
        m_generator thread rumble_at_generator_origin( localclientnum );

    switch ( newval )
    {
        case 0:
            m_generator generator_state_off( localclientnum, n_blend_time );
            break;
        case 1:
            m_generator generator_state_turn_on( localclientnum, n_blend_time );
            break;
        case 2:
            m_generator generator_state_power_up( localclientnum, n_blend_time );
            break;
        case 3:
            m_generator generator_state_power_down( localclientnum, n_blend_time );
            break;
        case 5:
            m_generator generator_state_damaged( localclientnum, n_blend_time );
            break;
        case 4:
            m_generator generator_state_turn_off( localclientnum, n_blend_time );
            break;
        default:
            break;
    }
}

rumble_at_generator_origin( localclientnumber )
{
    self endon( "entityshutdown" );

    if ( !isdefined( self.playing_rumble_loop ) )
        self.playing_rumble_loop = 0;

    if ( !self.playing_rumble_loop )
    {
        self.playing_rumble_loop = 1;
        self playrumblelooponentity( localclientnumber, "generator_active" );
        self waittill( "stop_rumble_loop" );
        self stoprumble( localclientnumber, "generator_active" );
        self.playing_rumble_loop = 0;
    }
}

generator_state_off( localclientnumber, n_blend_time )
{
    self notify( "stop_rumble_loop" );
    self generator_sound_disable();
    self generator_fx_disable( localclientnumber );
    self generator_offline_light_enable( localclientnumber );
}

generator_state_turn_on( localclientnumber, n_blend_time )
{
    self setanim( %fxanim_zom_tomb_generator_start_anim, 1, n_blend_time, 1 );
    self generator_fx_enable( localclientnumber );
    self generator_offline_light_disable( localclientnumber );
}

generator_state_power_up( localclientnumber, n_blend_time )
{
    self setanim( %fxanim_zom_tomb_generator_up_idle_anim, 1, n_blend_time, 1 );
    self generator_fx_enable( localclientnumber );
    self generator_offline_light_disable( localclientnumber );
}

generator_state_power_down( localclientnumber, n_blend_time )
{
    self setanim( %fxanim_zom_tomb_generator_down_idle_anim, 1, n_blend_time, 1 );
}

generator_state_damaged( localclientnumber, n_blend_time )
{
    self generator_state_power_down( localclientnumber, n_blend_time );
    self generator_play_damage_fx( localclientnumber );
}

generator_play_damage_fx( localclientnumber )
{
    self thread _generator_play_spark_fx( localclientnumber );
    self thread _generator_play_steam_fx( localclientnumber );
}

_generator_play_spark_fx( localclientnumber )
{
    self notify( "generator_starts_spark_fx" );
    self endon( "generator_starts_spark_fx" );
    self endon( "generator_stop_damage_fx" );

    if ( !isdefined( self.n_spark_fx ) )
        self.n_spark_fx = [];

    a_tags = array( "fx_side_exhaust01", "fx_frnt_exhaust", "fx_side_exhaust02", "j_piston_01" );

    while ( true )
    {
        self.n_spark_fx[localclientnumber] = playfxontag( localclientnumber, level._effect["zone_capture_damage_spark"], self, random( a_tags ) );
        wait( randomfloatrange( 0.15, 0.35 ) );
    }
}

_generator_play_steam_fx( localclientnumber )
{
    self notify( "generator_starts_steam_fx" );
    self endon( "generator_starts_steam_fx" );
    self endon( "generator_stop_damage_fx" );

    if ( !isdefined( self.n_steam_fx ) )
        self.n_steam_fx = [];

    a_tags = array( "fx_side_exhaust01", "fx_frnt_exhaust", "fx_side_exhaust02", "j_piston_01" );

    while ( true )
    {
        self.n_steam_fx[localclientnumber] = playfxontag( localclientnumber, level._effect["zone_capture_damage_steam"], self, random( a_tags ) );
        wait( randomfloatrange( 0.25, 0.35 ) );
    }
}

generator_delete_damage_fx( localclientnumber )
{
    self notify( "generator_stop_damage_fx" );

    if ( isdefined( self.n_spark_fx ) && isdefined( self.n_spark_fx[localclientnumber] ) )
        deletefx( localclientnumber, self.n_spark_fx[localclientnumber], 1 );

    if ( isdefined( self.n_steam_fx ) && isdefined( self.n_steam_fx[localclientnumber] ) )
        deletefx( localclientnumber, self.n_steam_fx[localclientnumber], 1 );
}

generator_state_turn_off( localclientnumber, n_blend_time )
{
    self setanim( %fxanim_zom_tomb_generator_end_anim, 1, n_blend_time, 1 );
    self generator_fx_disable( localclientnumber );
    self generator_offline_light_enable( localclientnumber );
}

generator_sound_enable( newval )
{
    if ( !isdefined( self.snddonutent ) )
    {
        sndorigin = self gettagorigin( "j_generator_pole" );
        self.snddonutent = spawn( 0, sndorigin, "script_origin" );
        self.snddonutent linkto( self, "j_generator_pole" );
        playsound( 0, "zmb_capturezone_donut_start", self.origin );
        self.snddonutent thread snddemojumpmonitor();
    }

    pitch = scale_speed( 0, 1, 0.8, 1.6, newval );
    loop_id = self.snddonutent playloopsound( "zmb_capturezone_rise", 1 );
    setsoundpitch( loop_id, pitch );
    self sndliquidvats( 1 );
}

generator_sound_disable()
{
    if ( isdefined( self.snddonut ) )
    {
        playsound( 0, "zmb_capturezone_donut_stop", self.origin );
        self.snddonutent delete();
        self.snddonutent = undefined;
    }

    self sndliquidvats( 0 );
}

generator_fx_enable( localclientnumber )
{
    self generator_fx_disable( localclientnumber );
    self.a_fx_power_on[localclientnumber] = playfxontag( localclientnumber, level._effect["capture_progression"], self, "j_generator_pole" );
    self.a_fx_exhaust[localclientnumber] = playfxontag( localclientnumber, level._effect["capture_exhaust"], self, "fx_rear_exhaust" );
}

generator_fx_disable( localclientnumber )
{
    if ( !isdefined( self.a_fx_power_on ) )
        self.a_fx_power_on = [];

    if ( isdefined( self.a_fx_power_on[localclientnumber] ) )
        deletefx( localclientnumber, self.a_fx_power_on[localclientnumber], 1 );

    if ( !isdefined( self.a_fx_exhaust ) )
        self.a_fx_exhaust = [];

    if ( isdefined( self.a_fx_exhaust[localclientnumber] ) )
        deletefx( localclientnumber, self.a_fx_exhaust[localclientnumber], 1 );

    self generator_delete_damage_fx( localclientnumber );
}

generator_offline_light_disable( localclientnumber )
{
    if ( !isdefined( self.a_fx_light ) )
        self.a_fx_light = [];

    if ( isdefined( self.a_fx_light[localclientnumber] ) )
        deletefx( localclientnumber, self.a_fx_light[localclientnumber], 1 );
}

generator_offline_light_enable( localclientnumber )
{
    self thread loop_generator_offline_light( localclientnumber );
}

loop_generator_offline_light( localclientnumber )
{
    self notify( "starting_generator_offline_light_loop" );
    self endon( "starting_generator_offline_light_loop" );
    self endon( "generator_state_changed" );

    while ( true )
    {
        self generator_offline_light_disable( localclientnumber );
        self.a_fx_light[localclientnumber] = playfxontag( localclientnumber, level._effect["zapper_light_notready"], self, "tag_pole_top" );
        wait 9;
    }
}

scale_speed( x1, x2, y1, y2, z )
{
    if ( z < x1 )
        z = x1;

    if ( z > x2 )
        z = x2;

    dx = x2 - x1;
    n = ( z - x1 ) / dx;
    dy = y2 - y1;
    w = n * dy + y1;
    return w;
}

sndliquidvats( start )
{
    if ( !isdefined( self.b_liquid_vats_sound_enabled ) )
        self.b_liquid_vats_sound_enabled = 0;

    origin1 = self gettagorigin( "vat_01_sound" );
    origin2 = self gettagorigin( "vat_02_sound" );

    if ( start )
    {
        if ( !self.b_liquid_vats_sound_enabled )
        {
            playloopat( "zmb_capturezone_vat_loop", origin1 );
            playloopat( "zmb_capturezone_vat_loop", origin2 );
            self.b_liquid_vats_sound_enabled = 1;
        }
    }
    else
    {
        stoploopat( "zmb_capturezone_vat_loop", origin1 );
        stoploopat( "zmb_capturezone_vat_loop", origin2 );
        self.b_liquid_vats_sound_enabled = 0;
    }
}

monolith_crysal_glow( localclientnumber, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_crystal = get_monolith_crystal_model( fieldname, localclientnumber );

    if ( newval )
    {
        m_crystal thread crystal_flicker( localclientnumber, 0.65, 0.85, 2.0, 4.0, 0.5, 3.0 );
        m_crystal stoploopsound( 1 );
        clientscripts\mp\_fx::deactivate_exploder( level.zone_capture_exploder_ids[fieldname] );
        level thread sndexploderloop( 0, level.zone_capture_exploder_ids[fieldname] );
    }
    else
    {
        m_crystal thread crystal_flicker( localclientnumber, 0, 0.2, 0.7, 1.0, 0.05, 0.35 );
        m_crystal playloopsound( "amb_monolith_glow" );
        clientscripts\mp\_fx::activate_exploder( level.zone_capture_exploder_ids[fieldname] );
        level thread sndexploderloop( 1, level.zone_capture_exploder_ids[fieldname] );
    }
}

sndexploderloop( play, num )
{
    origin = level.createfxexploders[num][0].v["origin"];

    if ( play )
        playloopat( "amb_monolith_sparks", origin );
    else
        stoploopat( "amb_monolith_sparks", origin );
}

crystal_flicker( localclientnumber, n_glow_value_low, n_glow_value_high, n_time_update_low, n_time_update_high, n_hold_time_low, n_hold_time_high )
{
    self notify( "flicker_update" );
    self endon( "flicker_update" );

    if ( !isdefined( self.n_glow_value ) )
        self.n_glow_value = n_glow_value_low;

    while ( true )
    {
        n_glow_value_target = randomfloatrange( n_glow_value_low, n_glow_value_high );
        n_transition_time = randomfloatrange( n_time_update_low, n_time_update_high );
        n_steps = int( n_transition_time / 0.0167 );
        n_change_per_step = ( n_glow_value_target - self.n_glow_value ) / n_steps;

        for ( i = 0; i < n_steps; i++ )
        {
            self.n_glow_value = self.n_glow_value + n_change_per_step;
            self setshaderconstant( localclientnumber, 2, self.n_glow_value, 0, 0, 0 );
            wait 0.0167;
        }

        wait( randomfloatrange( n_hold_time_low, n_hold_time_high ) );
    }
}

crystal_glow_lerp_to_value( localclientnumber, n_glow_value_target, n_transition_time )
{
    self notify( "flicker_update" );
    self endon( "flicker_update" );

    if ( !isdefined( self.n_glow_value ) )
        self.n_glow_value = 1;

    n_steps = int( n_transition_time / 0.0167 );
    n_change_per_step = ( n_glow_value_target - self.n_glow_value ) / n_steps;

    for ( i = 0; i < n_steps; i++ )
    {
        self.n_glow_value = self.n_glow_value + n_change_per_step;
        self setshaderconstant( localclientnumber, 2, self.n_glow_value, 0, 0, 0 );
        wait 0.0167;
    }
}

get_monolith_crystal_model( str_targetname, localclientnum )
{
    if ( !isdefined( level.zone_capture_crystals ) )
        level.zone_capture_crystals = [];

    if ( !isdefined( level.zone_capture_crystals[localclientnum] ) )
        level.zone_capture_crystals[localclientnum] = [];

    if ( !isdefined( level.zone_capture_crystals[localclientnum][str_targetname] ) )
    {
        level.zone_capture_crystals[localclientnum][str_targetname] = getent( localclientnum, str_targetname, "targetname" );
        level.zone_capture_crystals[localclientnum][str_targetname].mapped_shader_constant = [];
        level.zone_capture_crystals[localclientnum][str_targetname].mapped_shader_constant[localclientnum] = 0;
    }

    level.zone_capture_crystals[localclientnum][str_targetname] waittill_dobj( localclientnum );

    if ( !level.zone_capture_crystals[localclientnum][str_targetname].mapped_shader_constant[localclientnum] )
    {
        level.zone_capture_crystals[localclientnum][str_targetname] mapshaderconstant( localclientnum, 2, "ScriptVector0", 0.65 );
        level.zone_capture_crystals[localclientnum][str_targetname].mapped_shader_constant[localclientnum] = 1;
    }

    assert( isdefined( level.zone_capture_crystals[localclientnum][str_targetname] ), "generator with name " + str_targetname + " is missing in level.zone_capture_crystals array!" );
    return level.zone_capture_crystals[localclientnum][str_targetname];
}

pap_monolith_ring_callback( localclientnumber, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_ring = get_monolith_ring_model( localclientnumber );

    if ( isdefined( m_ring ) )
    {
        if ( newval )
        {
            m_ring thread lerp_glow_to_value( localclientnumber, 3 );
            m_ring thread pap_ring_pulled_down_anim();
        }
        else
        {
            m_ring thread lerp_glow_to_value( localclientnumber, 0 );
            m_ring thread pap_ring_released_anim( oldval );
        }
    }

    m_pack_a_punch = get_pack_a_punch_model( localclientnumber );

    if ( isdefined( m_pack_a_punch ) )
    {
        if ( newval )
            m_pack_a_punch thread crystal_flicker( localclientnumber, 0, 0.2, 0.7, 1.0, 0.05, 0.35 );
        else
            m_pack_a_punch thread crystal_glow_lerp_to_value( localclientnumber, 0.65, 5 );
    }
}

pap_ring_pulled_down_anim()
{
    self notify( "pap_ring_pulling_down" );
    self endon( "pap_ring_released" );
    self clear_all_pap_ring_anims();
    self setanim( %fxanim_zom_tomb_monolith_inductor_pull_anim, 1, 0.2 );
    waitrealtime( getanimlength( %fxanim_zom_tomb_monolith_inductor_pull_anim ) - 0.2 );
    self clearanim( %fxanim_zom_tomb_monolith_inductor_pull_anim, 0.2 );
    self setanim( %fxanim_zom_tomb_monolith_inductor_pull_idle_anim, 1, 0.2 );
}

pap_ring_released_anim( oldval )
{
    self notify( "pap_ring_released" );
    self endon( "pap_ring_pulling_down" );
    self clear_all_pap_ring_anims();

    if ( oldval )
    {
        self setanim( %fxanim_zom_tomb_monolith_inductor_release_anim, 1, 0.2 );
        waitrealtime( getanimlength( %fxanim_zom_tomb_monolith_inductor_release_anim ) - 0.2 );
        self clear_all_pap_ring_anims();
    }

    self setanim( %fxanim_zom_tomb_monolith_inductor_idle_anim, 1, 0.2 );
}

pap_monolith_ring_shake( localclientnumber, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_ring = get_monolith_ring_model( localclientnumber );
    m_ring endon( "pap_ring_pulling_down" );

    if ( newval == 1 )
    {
        m_ring clear_all_pap_ring_anims();
        m_ring setanim( %fxanim_zom_tomb_monolith_inductor_shake_anim, 1, 0.2 );
        waitrealtime( getanimlength( %fxanim_zom_tomb_monolith_inductor_shake_anim ) - 0.2 );
        m_ring clearanim( %fxanim_zom_tomb_monolith_inductor_shake_anim, 0.2 );
        m_ring setanim( %fxanim_zom_tomb_monolith_inductor_idle_anim, 1, 0.2 );
    }
}

clear_all_pap_ring_anims()
{
    self clearanim( %fxanim_zom_tomb_monolith_inductor_pull_anim, 0.2 );
    self clearanim( %fxanim_zom_tomb_monolith_inductor_pull_idle_anim, 0.2 );
    self clearanim( %fxanim_zom_tomb_monolith_inductor_release_anim, 0.2 );
    self clearanim( %fxanim_zom_tomb_monolith_inductor_shake_anim, 0.2 );
    self clearanim( %fxanim_zom_tomb_monolith_inductor_idle_anim, 0.2 );
}

lerp_glow_to_value( localclientnumber, n_value )
{
    self notify( "new_glow_lerp_thread_started" );
    self endon( "new_glow_lerp_thread_started" );

    if ( !isdefined( self.n_glow_value ) )
        self.n_glow_value = [];

    if ( !isdefined( self.n_glow_value[localclientnumber] ) )
        self.n_glow_value[localclientnumber] = 0;

    n_delta = n_value - self.n_glow_value[localclientnumber];
    n_increment = n_delta / 4.5 * 0.0167;

    while ( self.n_glow_value[localclientnumber] != n_value )
    {
        self.n_glow_value[localclientnumber] = clamp( self.n_glow_value[localclientnumber] + n_increment, 0, 3 );
        self setshaderconstant( localclientnumber, 3, 0, self.n_glow_value[localclientnumber], 0, 0 );
        wait 0.0167;
    }
}

get_monolith_ring_model( localclientnumber )
{
    if ( !isdefined( level.zone_capture_monolith_ring ) )
        level.zone_capture_monolith_ring = [];

    if ( !isdefined( level.zone_capture_monolith_ring[localclientnumber] ) )
        level.zone_capture_monolith_ring[localclientnumber] = getent( localclientnumber, "pap_monolith_ring", "targetname" );

    level.zone_capture_monolith_ring[localclientnumber] waittill_dobj( localclientnumber );

    if ( !level.zone_capture_monolith_ring[localclientnumber] hasanimtree() )
    {
        level.zone_capture_monolith_ring[localclientnumber] mapshaderconstant( localclientnumber, 3, "ScriptVector0", 0, 0, 0, 0 );
        level.zone_capture_monolith_ring[localclientnumber] useanimtree( #animtree );
    }

    return level.zone_capture_monolith_ring[localclientnumber];
}

emergence_hole_callback( localclientnumber, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isdefined( self ) )
        return;

    if ( newval )
        self emergence_hole_spawn( localclientnumber );
    else
    {
        b_delete_despawn_fx = self emergence_hole_despawn( localclientnumber, oldval && !bnewent && !bwasdemojump );
        self emergence_hole_fx_stop( localclientnumber, b_delete_despawn_fx );
    }
}

emergence_hole_spawn( localclientnumber )
{
    self emergence_hole_fx_stop( localclientnumber );
    self.n_fx_spawn[localclientnumber] = playfxontag( localclientnumber, level._effect["tesla_elec_kill"], self, "tag_origin" );
    self.n_fx_loop[localclientnumber] = playfxontag( localclientnumber, level._effect["screecher_hole"], self, "tag_origin" );

    if ( !isdefined( self.sndent ) )
    {
        self.sndent = spawn( localclientnumber, self.origin, "script_origin" );
        self.sndent thread snddemojumpmonitor();
    }

    self.sndent playloopsound( "zmb_capturezone_portal_loop", 2 );
    playsound( localclientnumber, "zmb_capturezone_portal_start", self.origin );
}

snddemojumpmonitor()
{
    self endon( "entityshutdown" );
    level waittill( "demo_jump" );
    self delete();
}

emergence_hole_despawn( localclientnumber, b_do_despawn )
{
    if ( b_do_despawn )
    {
        b_delete_despawn_fx = 0;
        playfxontag( localclientnumber, level._effect["tesla_elec_kill"], self, "tag_origin" );
        playsound( localclientnumber, "zmb_capturezone_portal_stop" );
    }

    return !b_do_despawn;
}

emergence_hole_fx_stop( localclientnumber, b_delete_despawn_fx )
{
    if ( !isdefined( b_delete_despawn_fx ) )
        b_delete_despawn_fx = 1;

    if ( !isdefined( self.n_fx_spawn ) )
        self.n_fx_spawn = [];

    if ( !isdefined( self.n_fx_loop ) )
        self.n_fx_loop = [];

    if ( !isdefined( self.n_fx_despawn ) )
        self.n_fx_despawn = [];

    if ( isdefined( self.n_fx_loop[localclientnumber] ) )
    {
        deletefx( localclientnumber, self.n_fx_spawn[localclientnumber], 1 );
        self.n_fx_spawn[localclientnumber] = undefined;
    }

    if ( isdefined( self.n_fx_loop[localclientnumber] ) )
    {
        deletefx( localclientnumber, self.n_fx_loop[localclientnumber], 1 );
        self.n_fx_loop[localclientnumber] = undefined;
    }

    if ( b_delete_despawn_fx )
    {
        if ( isdefined( self.n_fx_despawn[localclientnumber] ) )
        {
            deletefx( localclientnumber, self.n_fx_despawn[localclientnumber], 1 );
            self.n_fx_despawn[localclientnumber] = undefined;
        }
    }

    if ( isdefined( self.sndent ) )
        self.sndent delete();
}

capture_zombie_riser_fx()
{
    while ( !isdefined( self._aitype ) )
        wait 0.0167;

    if ( self._aitype == "zm_tomb_basic_zone_capture" )
    {
        s_info = spawnstruct();
        s_info.burst_fx = level._effect["zone_capture_zombie_spawn"];
        s_info.billow_fx = level._effect["zone_capture_zombie_spawn"];
        s_info.type = "none";
        return s_info;
    }
}

register_pack_a_punch_anim_sequence()
{
    add_pack_a_punch_progress_anims( 0, undefined, %fxanim_zom_tomb_pack_return_pc1_anim );
    add_pack_a_punch_progress_anims( 1, %fxanim_zom_tomb_packapunch_pc1_anim, %fxanim_zom_tomb_pack_return_pc2_anim );
    add_pack_a_punch_progress_anims( 2, %fxanim_zom_tomb_packapunch_pc2_anim, %fxanim_zom_tomb_pack_return_pc3_anim );
    add_pack_a_punch_progress_anims( 3, %fxanim_zom_tomb_packapunch_pc3_anim, %fxanim_zom_tomb_pack_return_pc4_anim );
    add_pack_a_punch_progress_anims( 4, %fxanim_zom_tomb_packapunch_pc4_anim, %fxanim_zom_tomb_pack_return_pc5_anim );
    add_pack_a_punch_progress_anims( 5, %fxanim_zom_tomb_packapunch_pc5_anim, %fxanim_zom_tomb_pack_return_pc6_anim );
    add_pack_a_punch_progress_anims( 6, %fxanim_zom_tomb_packapunch_pc6_anim, undefined );
}

play_pap_anim( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_pap = get_pack_a_punch_model( localclientnum );
    b_snap_to_anim = bnewent || binitialsnap || bwasdemojump;

    if ( newval > oldval || b_snap_to_anim )
    {
        m_pap clear_all_pack_a_punch_anims();

        for ( i = 1; i <= newval; i++ )
        {
            n_anim_time = 1.0;
            n_anim_rate = 0.0;

            if ( i == newval && !b_snap_to_anim )
            {
                n_anim_time = 0.0;
                n_anim_rate = 1.0;
            }

            anim_assemble = level.pack_a_punch_anim_sequence["assemble"][i];
            m_pap setanim( anim_assemble, 1.0, 0.0, n_anim_rate );
            m_pap setanimtime( anim_assemble, n_anim_time );
        }
    }
    else if ( newval < oldval )
    {
        for ( i = level.pack_a_punch_anim_sequence["disassemble"].size - 1; i >= newval; i-- )
        {
            n_anim_time = 1.0;
            n_anim_rate = 0.0;

            if ( i == newval )
            {
                n_anim_time = 0.0;
                n_anim_rate = 1.0;
            }

            anim_clear = level.pack_a_punch_anim_sequence["assemble"][i + 1];

            if ( isdefined( anim_clear ) )
                m_pap clearanim( anim_clear, 0.0 );

            anim_disassemble = level.pack_a_punch_anim_sequence["disassemble"][i];
            m_pap setanim( anim_disassemble, 1.0, 0.0, n_anim_rate );
            m_pap setanimtime( anim_disassemble, n_anim_time );
        }
    }
}

clear_all_pack_a_punch_anims()
{
    foreach ( anim_name in level.pack_a_punch_anim_sequence["assemble"] )
        self clearanim( anim_name, 0 );

    foreach ( anim_name in level.pack_a_punch_anim_sequence["disassemble"] )
        self clearanim( anim_name, 0 );
}

add_pack_a_punch_progress_anims( n_index, anim_assemble, anim_disassemble )
{
    if ( !isdefined( level.pack_a_punch_anim_sequence ) )
        level.pack_a_punch_anim_sequence = [];

    if ( !isdefined( level.pack_a_punch_anim_sequence["assemble"] ) )
        level.pack_a_punch_anim_sequence["assemble"] = [];

    if ( !isdefined( level.pack_a_punch_anim_sequence["disassemble"] ) )
        level.pack_a_punch_anim_sequence["disassemble"] = [];

    level.pack_a_punch_anim_sequence["assemble"][n_index] = anim_assemble;
    level.pack_a_punch_anim_sequence["disassemble"][n_index] = anim_disassemble;
}

get_pack_a_punch_model( localclientnumber )
{
    if ( !isdefined( level.pack_a_punch_model ) )
        level.pack_a_punch_model = [];

    if ( !isdefined( level.pack_a_punch_model[localclientnumber] ) )
        level.pack_a_punch_model[localclientnumber] = getent( localclientnumber, "pap_cs", "targetname" );

    level.pack_a_punch_model[localclientnumber] waittill_dobj( localclientnumber );

    if ( !level.pack_a_punch_model[localclientnumber] hasanimtree() )
    {
        level.pack_a_punch_model[localclientnumber] useanimtree( #animtree );
        level.pack_a_punch_model[localclientnumber] mapshaderconstant( localclientnumber, 2, "ScriptVector0", 1 );
    }

    return level.pack_a_punch_model[localclientnumber];
}

init_custom_pap()
{
    waitforallclients();
    a_players = getlocalplayers();

    for ( localclientnum = 0; localclientnum < a_players.size; localclientnum++ )
        e_custom_pap = get_pack_a_punch_model( localclientnum );
}

zone_capture_zombie_callback( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
    {
        self._eyeglow_fx_override = level._effect["crusader_zombie_eyes"];
        self deletezombieeyes( localclientnum );
        self createzombieeyes( localclientnum );
        self capture_zombie_torso_fx_enable( localclientnum );
    }
}

capture_zombie_torso_fx_enable( localclientnumber )
{
    self capture_zombie_torso_fx_disable( localclientnumber );
    self.a_fx_torso[localclientnumber] = playfxontag( localclientnumber, level._effect["zone_capture_zombie_torso_fx"], self, "J_Spine4" );

    if ( !isdefined( self.sndent ) )
    {
        self.sndent = spawn( 0, self.origin, "script_origin" );
        self.sndent linkto( self );
        self thread snddeleteent( self.sndent );
    }

    self.sndent playloopsound( "zmb_capturezone_zombie_loop", 1 );
}

snddeleteent( ent )
{
    self waittill_any( "death", "entityshutdown" );

    if ( isdefined( ent ) )
        ent delete();
}

capture_zombie_torso_fx_disable( localclientnumber )
{
    if ( !isdefined( self.a_fx_torso ) )
        self.a_fx_torso = [];

    if ( isdefined( self.a_fx_torso[localclientnumber] ) )
        deletefx( localclientnumber, self.a_fx_torso[localclientnumber], 1 );
}

register_exploders_with_capture_zones()
{
    add_exploder_id_to_zone_capture_field( "zone_capture_monolith_crystal_1", 5001 );
    add_exploder_id_to_zone_capture_field( "zone_capture_monolith_crystal_2", 5002 );
    add_exploder_id_to_zone_capture_field( "zone_capture_monolith_crystal_3", 5003 );
    add_exploder_id_to_zone_capture_field( "zone_capture_monolith_crystal_4", 5004 );
    add_exploder_id_to_zone_capture_field( "zone_capture_monolith_crystal_5", 5005 );
    add_exploder_id_to_zone_capture_field( "zone_capture_monolith_crystal_6", 5006 );
}

add_exploder_id_to_zone_capture_field( str_field_name, n_exploder_id )
{
    if ( !isdefined( level.zone_capture_exploder_ids ) )
        level.zone_capture_exploder_ids = [];

    if ( !isdefined( level.zone_capture_exploder_ids[str_field_name] ) )
        level.zone_capture_exploder_ids[str_field_name] = n_exploder_id;
}

register_perk_machine_smoke_struct_references()
{
    register_perk_machine_smoke_struct_with_field_name( "zone_capture_perk_machine_smoke_fx_1", "revive_pipes" );
    register_perk_machine_smoke_struct_with_field_name( "zone_capture_perk_machine_smoke_fx_3", "speedcola_pipes" );
    register_perk_machine_smoke_struct_with_field_name( "zone_capture_perk_machine_smoke_fx_4", "jugg_pipes" );
    register_perk_machine_smoke_struct_with_field_name( "zone_capture_perk_machine_smoke_fx_5", "staminup_pipes" );
}

register_perk_machine_smoke_struct_with_field_name( str_field_name, str_perk_machine_struct_targetname )
{
    if ( !isdefined( level.perk_machine_smoke_struct_references ) )
        level.perk_machine_smoke_struct_references = [];

    if ( !isdefined( level.perk_machine_smoke_struct_references[str_field_name] ) )
        level.perk_machine_smoke_struct_references[str_field_name] = str_perk_machine_struct_targetname;
}

perk_machine_smoke_fx_always_on_callback( localclientnumber, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
    {
        s_pipes_mule_kick = getstruct( "mulekick_pipes", "targetname" );
        s_pipes_mule_kick perk_pipe_smoke_fx_enable( localclientnumber );
    }
}

perk_machine_smoke_fx_callback( localclientnumber, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    s_pipes = get_perk_machine_smoke_fx_struct_from_field_name( fieldname );

    if ( isdefined( s_pipes ) )
    {
        if ( newval == 1 )
            s_pipes perk_pipe_smoke_fx_enable( localclientnumber );
        else
            s_pipes perk_pipe_smoke_fx_disable( localclientnumber );
    }
}

get_perk_machine_smoke_fx_struct_from_field_name( str_field_name )
{
    s_fx = undefined;

    if ( isdefined( level.perk_machine_smoke_struct_references[str_field_name] ) )
    {
        if ( !isdefined( level.perk_machine_smoke_structs ) )
            level.perk_machine_smoke_structs = [];

        if ( !isdefined( level.perk_machine_smoke_structs[level.perk_machine_smoke_struct_references[str_field_name]] ) )
            level.perk_machine_smoke_structs[level.perk_machine_smoke_struct_references[str_field_name]] = getstruct( level.perk_machine_smoke_struct_references[str_field_name], "targetname" );

        s_fx = level.perk_machine_smoke_structs[level.perk_machine_smoke_struct_references[str_field_name]];
    }

    return s_fx;
}

perk_pipe_smoke_fx_disable( localclientnumber )
{
    if ( !isdefined( self.a_fx ) )
        self.a_fx = [];

    if ( isdefined( self.a_fx[localclientnumber] ) )
        deletefx( localclientnumber, self.a_fx[localclientnumber], 0 );
}

perk_pipe_smoke_fx_enable( localclientnumber )
{
    self perk_pipe_smoke_fx_disable( localclientnumber );
    self.a_fx[localclientnumber] = playfx( localclientnumber, level._effect["perk_pipe_smoke"], self.origin, anglestoforward( self.angles ) );
}
