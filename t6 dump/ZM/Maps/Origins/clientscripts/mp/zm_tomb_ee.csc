// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\_filter;
#include clientscripts\mp\_audio;
#include clientscripts\mp\zm_tomb_ee_lights;

init()
{
    registerclientfield( "world", "wagon_1_fire", 14000, 1, "int", ::toggle_wagon_fire_fx, 0 );
    registerclientfield( "world", "wagon_2_fire", 14000, 1, "int", ::toggle_wagon_fire_fx, 0 );
    registerclientfield( "world", "wagon_3_fire", 14000, 1, "int", ::toggle_wagon_fire_fx, 0 );
    registerclientfield( "world", "ee_sam_portal", 14000, 2, "int", ::set_ee_portal_fx, 0 );
    registerclientfield( "actor", "ee_zombie_fist_fx", 14000, 1, "int", ::toggle_fist_fx, 0 );
    registerclientfield( "actor", "ee_zombie_soul_portal", 14000, 1, "int", ::zombie_soul_portal_fx, 0 );
    registerclientfield( "actor", "ee_zombie_tablet_fx", 14000, 1, "int", ::tablet_fx, 0 );
    registerclientfield( "vehicle", "ee_plane_fx", 14000, 1, "int", ::run_plane_fx, 0 );
    registerclientfield( "toplayer", "ee_beacon_reward", 14000, 1, "int", ::toggle_beacon_portal, 0 );
    registerclientfield( "world", "ee_ending", 14000, 1, "int", ::toggle_ending, 1 );
    clientscripts\mp\zm_tomb_ee_lights::main();
}

toggle_ending( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
        setdvar( "ui_zm_outromovie", "zm_tomb_ee" );
}

toggle_wagon_fire_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        level thread wagon_fire_fx_loop( localclientnum, fieldname );
        level thread sndwagonfire( 1, fieldname );
    }
    else
    {
        level notify( "stop_" + fieldname );
        level thread sndwagonfire( 0, fieldname );
    }
}

wagon_fire_fx_loop( localclientnum, fieldname )
{
    level notify( "stop_" + fieldname );
    self endon( "stop_" + fieldname );
    s_pos = getstruct( fieldname, "targetname" );

    while ( true )
    {
        playfx( localclientnum, level._effect["wagon_fire"], s_pos.origin, anglestoforward( s_pos.angles ), anglestoup( s_pos.angles ) );
        wait 0.5;
    }
}

sndwagonfire( ison, fieldname )
{
    struct = getstruct( fieldname, "targetname" );
    origin = struct.origin;

    if ( ison )
        playloopat( "amb_fire_xlg", origin );
    else
        stoploopat( "amb_fire_xlg", origin );
}

toggle_fist_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        if ( !isdefined( self.has_soul ) )
        {
            self.has_soul = 1;
            self.fist_fx_r = playfxontag( localclientnum, level._effect["fist_glow"], self, "J_Wrist_RI" );
            self.fist_fx_l = playfxontag( localclientnum, level._effect["fist_glow"], self, "J_Wrist_LE" );
        }

        if ( !isdefined( self.sndfist ) )
        {
            self.sndfist = spawn( 0, self.origin, "script_origin" );
            self.sndfist linkto( self );
            self.sndfist playloopsound( "zmb_squest_punchtime_fist_loop", 1 );
            self thread snddeletesndent( self.sndfist );
        }
    }
    else
    {
        if ( isdefined( self.has_soul ) )
        {
            self.has_soul = undefined;
            stopfx( localclientnum, self.fist_fx_r );
            stopfx( localclientnum, self.fist_fx_l );
        }

        self notify( "sndDeleteEnt" );
    }
}

snddeletesndent( ent )
{
    self waittill_any( "death", "entityshutdown", "sndDeleteEnt" );
    ent delete();
}

zombie_soul_portal_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    v_dest = getent( localclientnum, "ee_sam_portal", "targetname" ).origin;
    e_fx = spawn( localclientnum, self gettagorigin( "J_SpineUpper" ), "script_model" );
    e_fx setmodel( "tag_origin" );
    playsound( localclientnum, "zmb_squest_charge_soul_leave", self.origin );
    playfxontag( localclientnum, level._effect["staff_soul"], e_fx, "tag_origin" );
    e_fx moveto( v_dest + vectorscale( ( 0, 0, 1 ), 5.0 ), 1 );
    e_fx waittill( "movedone" );
    playsound( localclientnum, "zmb_squest_charge_soul_impact", v_dest );
    playfxontag( localclientnum, level._effect["staff_charge"], e_fx, "tag_origin" );
    wait 0.3;
    e_fx delete();
}

set_ee_portal_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    e_fx = getent( localclientnum, "ee_sam_portal", "targetname" );

    if ( isdefined( e_fx.fx_id ) )
    {
        e_fx stoploopsound( 5 );
        stopfx( localclientnum, e_fx.fx_id );
    }

    if ( newval == 1 )
    {
        e_fx.fx_id = playfxontag( localclientnum, level._effect["foot_box_glow"], e_fx, "tag_origin" );
        e_fx playloopsound( "zmb_squest_sam_portal_closed_loop", 1 );
    }
    else if ( newval == 2 )
    {
        e_fx.fx_id = playfxontag( localclientnum, level._effect["ee_vortex"], e_fx, "tag_origin" );
        playsound( 0, "zmb_squest_sam_portal_open", e_fx.origin );
        e_fx playloopsound( "zmb_squest_sam_portal_open_loop", 1 );
    }
}

run_plane_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );

    while ( true )
    {
        e_player = getlocalplayer( localclientnum );

        if ( isdefined( e_player ) && is_true( e_player.zombie_blood_fx ) && !isdefined( self.plane_fx ) )
            self.plane_fx = playfxontag( localclientnum, level._effect["fire_glow"], self, "tag_origin" );

        if ( isdefined( e_player ) && !is_true( e_player.zombie_blood_fx ) && isdefined( self.plane_fx ) )
        {
            stopfx( localclientnum, self.plane_fx );
            self.plane_fx = undefined;
        }

        wait 0.05;
    }
}

tablet_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    a_structs = getstructarray( "tablet_charge_pos", "targetname" );
    s_box = get_array_of_closest( self.origin, a_structs )[0];
    e_fx = spawn( localclientnum, self gettagorigin( "J_SpineUpper" ), "script_model" );
    e_fx setmodel( "tag_origin" );
    e_fx playsound( localclientnum, "zmb_squest_charge_soul_leave" );
    playfxontag( localclientnum, level._effect["staff_soul"], e_fx, "tag_origin" );
    e_fx moveto( s_box.origin, 1 );
    e_fx waittill( "movedone" );
    playsound( localclientnum, "zmb_squest_charge_soul_impact", e_fx.origin );
    playfxontag( localclientnum, level._effect["staff_charge"], e_fx, "tag_origin" );
    wait 0.3;
    e_fx delete();
}

toggle_beacon_portal( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        if ( !isdefined( self.beacon_portal ) )
        {
            self.beacon_portal = 1;
            self thread create_beacon_portal( localclientnum );
            self.m_reward = spawn( localclientnum, ( -141, 4464, -322 ) + ( 8, 35, 20 ), "script_model" );
            self.m_reward setmodel( getweaponmodel( "beacon_zm" ) );
            self.m_reward thread rotate_beacon( localclientnum );
        }
    }
    else if ( isdefined( self.beacon_portal ) )
    {
        self.beacon_portal = 0;
        self notify( "stop_beacon_portal" );
        self.m_reward delete();
    }
}

rotate_beacon( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "death" );
    self waittill_dobj( localclientnum );
    playfxontag( localclientnum, level._effect["staff_soul"], self, "tag_origin" );
    self playsound( localclientnum, "zmb_spawn_powerup" );
    self playloopsound( "zmb_spawn_powerup_loop", 0.5 );
    self movey( -50, 2, 0, 1 );
    self waittill( "movedone" );

    while ( true )
    {
        self rotateyaw( 360, 4 );
        self waittill( "rotatedone" );
    }
}

create_beacon_portal( localclientnum )
{
    self endon( "disconnect" );
    self endon( "stop_beacon_portal" );

    while ( true )
    {
        playfx( localclientnum, level._effect["bottle_glow"], ( -141, 4464, -322 ) + ( 60, 10, 25 ) );
        wait 0.1;
    }
}
