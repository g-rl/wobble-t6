// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_fx;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\_audio;
#include clientscripts\mp\zm_tomb_amb;

init()
{
    registerclientfield( "actor", "register_giant_robot", 14000, 1, "int", ::register_giant_robot );
    registerclientfield( "world", "start_anim_robot_0", 14000, 1, "int", ::toggle_robot_warning_lights );
    registerclientfield( "world", "start_anim_robot_1", 14000, 1, "int", ::toggle_robot_warning_lights );
    registerclientfield( "world", "start_anim_robot_2", 14000, 1, "int", ::toggle_robot_warning_lights );
    registerclientfield( "world", "play_foot_stomp_fx_robot_0", 14000, 2, "int", ::play_foot_stomp_fx );
    registerclientfield( "world", "play_foot_stomp_fx_robot_1", 14000, 2, "int", ::play_foot_stomp_fx );
    registerclientfield( "world", "play_foot_stomp_fx_robot_2", 14000, 2, "int", ::play_foot_stomp_fx );
    registerclientfield( "world", "play_foot_open_fx_robot_0", 14000, 2, "int", ::play_foot_open_fx );
    registerclientfield( "world", "play_foot_open_fx_robot_1", 14000, 2, "int", ::play_foot_open_fx );
    registerclientfield( "world", "play_foot_open_fx_robot_2", 14000, 2, "int", ::play_foot_open_fx );
    registerclientfield( "world", "eject_warning_fx_robot_0", 14000, 1, "int", ::play_eject_warning_fx );
    registerclientfield( "world", "eject_warning_fx_robot_1", 14000, 1, "int", ::play_eject_warning_fx );
    registerclientfield( "world", "eject_warning_fx_robot_2", 14000, 1, "int", ::play_eject_warning_fx );
    registerclientfield( "allplayers", "eject_steam_fx", 14000, 1, "int", ::play_eject_steam_fx );
    registerclientfield( "allplayers", "all_tubes_play_eject_steam_fx", 14000, 1, "int", ::all_tubes_play_eject_steam_fx );
    registerclientfield( "allplayers", "gr_eject_player_impact_fx", 14000, 1, "int", ::gr_eject_player_impact_fx );
    registerclientfield( "toplayer", "giant_robot_rumble_and_shake", 14000, 2, "int", ::giant_robot_rumble_and_shake, 0 );
    registerclientfield( "world", "church_ceiling_fxanim", 14000, 1, "int", ::church_ceiling_fxanim );
}

#using_animtree("zm_tomb_giant_robot_hatch");

init_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

register_giant_robot( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isdefined( level.a_giant_robots ) )
    {
        level.a_giant_robots = [];
        level.a_giant_robots[localclientnum] = [];
    }

    if ( self.model == "veh_t6_dlc_zm_robot_0" )
        level.a_giant_robots[localclientnum][0] = self;
    else if ( self.model == "veh_t6_dlc_zm_robot_1" )
        level.a_giant_robots[localclientnum][1] = self;
    else if ( self.model == "veh_t6_dlc_zm_robot_2" )
        level.a_giant_robots[localclientnum][2] = self;
}

play_foot_stomp_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    ai_robot = get_clientside_giant_robot_ai( localclientnum, fieldname );

    if ( !isdefined( ai_robot ) )
        return;

    ai_robot thread play_warning_lights_in_footprints_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump );

    if ( newval == 1 )
    {
        playfxontag( localclientnum, level._effect["robot_foot_stomp"], ai_robot, "tag_hatch_fx_ri" );
        origin = ai_robot gettagorigin( "tag_hatch_fx_ri" );
        playsound( 0, "zmb_robot_foot_impact", origin );
    }
    else if ( newval == 2 )
    {
        playfxontag( localclientnum, level._effect["robot_foot_stomp"], ai_robot, "tag_hatch_fx_le" );
        origin = ai_robot gettagorigin( "tag_hatch_fx_le" );
        playsound( 0, "zmb_robot_foot_impact", origin );
    }
}

play_foot_open_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    ai_robot = get_clientside_giant_robot_ai( localclientnum, fieldname );

    if ( !isdefined( ai_robot ) )
        return;

    v_fx_offset = vectorscale( ( 0, 0, 1 ), 56.0 );

    if ( newval == 1 )
    {
        v_fx_pos = ai_robot gettagorigin( "tag_hatch_fx_ri" );
        v_fx_pos = v_fx_pos - v_fx_offset;
        ai_robot.e_damage_fx = spawn( localclientnum, v_fx_pos, "script_model" );
        ai_robot.e_damage_fx setmodel( "tag_origin" );
        ai_robot.e_damage_fx linkto( ai_robot, "tag_hatch_fx_ri" );
        ai_robot.e_damage_fx playsound( 0, "zmb_zombieblood_3rd_plane_explode" );
        playfxontag( localclientnum, level._effect["mechz_death"], ai_robot.e_damage_fx, "tag_origin" );
    }
    else if ( newval == 2 )
    {
        v_fx_pos = ai_robot gettagorigin( "tag_hatch_fx_le" );
        v_fx_pos = v_fx_pos - v_fx_offset;
        ai_robot.e_damage_fx = spawn( localclientnum, v_fx_pos, "script_model" );
        ai_robot.e_damage_fx setmodel( "tag_origin" );
        ai_robot.e_damage_fx linkto( ai_robot, "tag_hatch_fx_le" );
        ai_robot.e_damage_fx playsound( 0, "zmb_zombieblood_3rd_plane_explode" );
        playfxontag( localclientnum, level._effect["mechz_death"], ai_robot.e_damage_fx, "tag_origin" );
    }
    else if ( isdefined( ai_robot.e_damage_fx ) )
        ai_robot.e_damage_fx delete();
}

play_eject_warning_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        s_origin = getstruct( fieldname, "targetname" );
        v_fx_pos = s_origin.origin;
        level.fieldname[localclientnum] = spawn( localclientnum, v_fx_pos, "script_model" );
        level.fieldname[localclientnum] setmodel( "tag_origin" );
        playfxontag( localclientnum, level._effect["eject_warning"], level.fieldname[localclientnum], "tag_origin" );
    }
    else if ( isdefined( level.fieldname[localclientnum] ) )
        level.fieldname[localclientnum] delete();
}

play_eject_steam_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
        self thread loop_eject_steam_fx( localclientnum );
    else
    {
        self notify( "stop_eject_steam_fx" );

        if ( isdefined( self.fieldname ) )
            stopfx( localclientnum, self.fieldname );
    }
}

loop_eject_steam_fx( localclientnum )
{
    self endon( "stop_eject_steam_fx" );
    a_s_tubes = getstructarray( "giant_robot_eject_tube", "script_noteworthy" );
    a_s_tubes = get_array_of_closest( self.origin, a_s_tubes );
    s_tube = a_s_tubes[0];
    self thread sndplaysteamfx( "stop_eject_steam_fx", s_tube.origin );

    while ( true )
    {
        self.fieldname = playfx( localclientnum, level._effect["eject_steam"], s_tube.origin, anglestoforward( s_tube.angles ), anglestoup( s_tube.angles ) );
        wait 0.1;
    }
}

all_tubes_play_eject_steam_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        a_s_alltubes = getstructarray( "giant_robot_eject_tube", "script_noteworthy" );
        a_s_alltubes = get_array_of_closest( self.origin, a_s_alltubes );
        n_robot_id = a_s_alltubes[0].script_int;
        level.a_s_tubes = [];
        level.a_s_tubes[localclientnum] = [];
        n_index = 0;

        foreach ( struct in a_s_alltubes )
        {
            if ( struct.script_int == n_robot_id )
            {
                struct thread loop_all_tube_steam( localclientnum );
                level.a_s_tubes[localclientnum][n_index] = struct;
                n_index++;
            }
        }
    }
    else if ( isdefined( level.a_s_tubes[localclientnum] ) )
    {
        foreach ( struct in level.a_s_tubes[localclientnum] )
            struct notify( "stop_all_tubes_eject_steam" );
    }
}

loop_all_tube_steam( localclientnum )
{
    self endon( "stop_all_tubes_eject_steam" );
    self thread sndplaysteamfx( "stop_all_tubes_eject_steam", self.origin );

    while ( true )
    {
        playfx( localclientnum, level._effect["eject_steam"], self.origin, anglestoforward( self.angles ), anglestoup( self.angles ) );
        wait 0.1;
    }
}

sndplaysteamfx( the_notify, origin )
{
    playloopat( "zmb_bot_timeout_steam", origin );
    self waittill( the_notify );
    stoploopat( "zmb_bot_timeout_steam", origin );
}

gr_eject_player_impact_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
        self.fieldname = playfx( localclientnum, level._effect["beacon_shell_explosion"], self.origin );
    else if ( isdefined( self.fieldname ) )
        stopfx( localclientnum, self.fieldname );
}

get_clientside_giant_robot_ai( localclientnum, fieldname )
{
    if ( !isdefined( level.a_giant_robots ) || !isdefined( level.a_giant_robots[localclientnum] ) )
        return undefined;

    ai_robot = undefined;

    if ( issubstr( fieldname, 0 ) )
    {
        ai_robot = level.a_giant_robots[localclientnum][0];

        if ( isdefined( ai_robot ) )
            ai_robot._index_for_lights = 0;
    }
    else if ( issubstr( fieldname, 1 ) )
    {
        ai_robot = level.a_giant_robots[localclientnum][1];

        if ( isdefined( ai_robot ) )
            ai_robot._index_for_lights = 1;
    }
    else
    {
        ai_robot = level.a_giant_robots[localclientnum][2];

        if ( isdefined( ai_robot ) )
            ai_robot._index_for_lights = 2;
    }

    return ai_robot;
}

toggle_robot_warning_lights( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isdefined( level.robot_light_positions ) )
    {
        level.robot_light_positions = [];
        level.robot_light_positions[0] = spawnstruct();
        level.robot_light_positions[0].struct_name = "nml_warn_light_fp_ref";
        level.robot_light_positions[0].warning_lights = getstructarray( "nml_foot_warn_light", "targetname" );
        assert( level.robot_light_positions[0].warning_lights.size > 0, "DID NOT FIND THE STRUCTS FOR THE FOOTPRINT LIGHTS - NML" );
        level.robot_light_positions[1] = spawnstruct();
        level.robot_light_positions[1].struct_name = "trench_warn_light_fp_ref";
        level.robot_light_positions[1].warning_lights = [];
        level.robot_light_positions[1].warning_lights = getstructarray( "trench_foot_warn_light", "targetname" );
        assert( level.robot_light_positions[1].warning_lights.size > 0, "DID NOT FIND THE STRUCTS FOR THE FOOTPRINT LIGHTS - TRENCHES" );
        level.robot_light_positions[2] = spawnstruct();
        level.robot_light_positions[2].struct_name = "church_warn_light_fp_ref";
        level.robot_light_positions[2].warning_lights = [];
        level.robot_light_positions[2].warning_lights = getstructarray( "church_foot_warn_light", "targetname" );
        assert( level.robot_light_positions[2].warning_lights.size > 0, "DID NOT FIND THE STRUCTS FOR THE FOOTPRINT LIGHTS - CHURCH" );
    }

    ai_robot = get_clientside_giant_robot_ai( localclientnum, fieldname );

    if ( !isdefined( ai_robot ) || !isdefined( level.robot_light_positions[ai_robot._index_for_lights] ) )
        return;

    if ( newval == 1 )
    {
        ai_robot.next_foot_left = getstruct( level.robot_light_positions[ai_robot._index_for_lights].struct_name + "_left", "targetname" );
        ai_robot.next_foot_right = getstruct( level.robot_light_positions[ai_robot._index_for_lights].struct_name + "_right", "targetname" );
        ai_robot turn_on_warning_lights( localclientnum, ai_robot.next_foot_left );
        ai_robot turn_on_warning_lights( localclientnum, ai_robot.next_foot_right );
    }
    else
    {
        ai_robot turn_off_all_warning_lights_for_this_robot( localclientnum );
        ai_robot.next_foot_left = undefined;
        ai_robot.next_foot_right = undefined;
    }
}

turn_on_warning_lights( localclientnum, struct_footprint )
{
    a_lights = get_warning_lights_closest( struct_footprint );

    foreach ( light in a_lights )
    {
        if ( !isdefined( light.fx_is_on_and_id ) )
        {
            if ( !isdefined( light.angles ) )
                light.angles = ( 0, 0, 0 );

            light.fx_is_on_and_id = playfx( localclientnum, level._effect["giant_robot_footstep_warning_light"], light.origin, anglestoforward( light.angles ), anglestoup( light.angles ) );
        }
    }
}

turn_off_warning_lights( localclientnum, struct_footprint )
{
    a_lights = get_warning_lights_closest( struct_footprint );

    foreach ( light in a_lights )
    {
        if ( isdefined( light.fx_is_on_and_id ) )
        {
            stopfx( localclientnum, light.fx_is_on_and_id );
            light.fx_is_on_and_id = undefined;
        }
    }
}

turn_off_all_warning_lights_for_this_robot( localclientnum )
{
    foreach ( light in level.robot_light_positions[self._index_for_lights].warning_lights )
    {
        if ( isdefined( light.fx_is_on_and_id ) )
        {
            stopfx( localclientnum, light.fx_is_on_and_id );
            light.fx_is_on_and_id = undefined;
        }
    }
}

get_warning_lights_closest( struct_footprint )
{
    a_close_lights = [];

    foreach ( light in level.robot_light_positions[self._index_for_lights].warning_lights )
    {
        if ( distancesquared( struct_footprint.origin, light.origin ) < 640000 )
            a_close_lights[a_close_lights.size] = light;
    }

    return a_close_lights;
}

play_warning_lights_in_footprints_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    wait 1.0;

    if ( newval == 1 )
    {
        if ( isdefined( self.next_foot_right ) )
        {
            foot_origin = self gettagorigin( "tag_hatch_fx_ri" );

            if ( distancesquared( self.next_foot_right.origin, foot_origin ) < 300 * 300 )
            {
                turn_off_warning_lights( localclientnum, self.next_foot_right );
                wait 0.05;

                if ( isdefined( self.next_foot_right.target ) )
                {
                    self.next_foot_right = getstruct( self.next_foot_right.target, "targetname" );
                    turn_on_warning_lights( localclientnum, self.next_foot_right );
                }
                else
                    self.next_foot_right = undefined;
            }
        }
    }
    else if ( newval == 2 )
    {
        if ( isdefined( self.next_foot_left ) )
        {
            foot_origin = self gettagorigin( "tag_hatch_fx_le" );

            if ( distancesquared( self.next_foot_left.origin, foot_origin ) < 300 * 300 )
            {
                turn_off_warning_lights( localclientnum, self.next_foot_left );
                wait 0.05;

                if ( isdefined( self.next_foot_left.target ) )
                {
                    self.next_foot_left = getstruct( self.next_foot_left.target, "targetname" );
                    turn_on_warning_lights( localclientnum, self.next_foot_left );
                }
                else
                    self.next_foot_left = undefined;
            }
        }
    }
}

giant_robot_rumble_and_shake( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "disconnect" );

    if ( newval == 3 )
    {
        self earthquake( 0.6, 1.5, self.origin, 100 );
        self playrumbleonentity( localclientnum, "artillery_rumble" );
        level thread clientscripts\mp\zm_tomb_amb::snd_shake_hvy();
    }
    else if ( newval == 2 )
    {
        self earthquake( 0.3, 1.5, self.origin, 100 );
        self playrumbleonentity( localclientnum, "shotgun_fire" );
        level thread clientscripts\mp\zm_tomb_amb::snd_shake_med();
    }
    else if ( newval == 1 )
    {
        self earthquake( 0.1, 1.0, self.origin, 100 );
        self playrumbleonentity( localclientnum, "damage_heavy" );
        level thread clientscripts\mp\zm_tomb_amb::snd_shake_lgt();
    }
    else
        self notify( "stop_giant_robot_rumble_and_shake" );
}

#using_animtree("fxanim_props_dlc4");

church_ceiling_fxanim( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        n_time = getanimlength( level.scr_anim["fxanim_props_dlc4"]["church_ceiling"] );
        e_church_ceiling = getent( localclientnum, "church_ceiling", "targetname" );
        e_church_ceiling useanimtree( #animtree );
        e_church_ceiling setanim( level.scr_anim["fxanim_props_dlc4"]["church_ceiling"], 1, 0.1, 1 );
    }
}
