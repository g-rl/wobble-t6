// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\_audio;

#using_animtree("zm_tomb_tank");

init()
{
    registerclientfield( "vehicle", "tank_tread_fx", 14000, 1, "int", ::play_tread_fx );
    registerclientfield( "vehicle", "tank_flamethrower_fx", 14000, 2, "int", ::play_flamethrower_fx );
    registerclientfield( "vehicle", "tank_cooldown_fx", 14000, 2, "int", ::play_tank_fx );
    scriptmodelsuseanimtree( #animtree );
}

play_tread_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == oldval )
        return;

    if ( newval == 1 )
    {
/#
        println( "Mark IV Tank Tread FX ON" );
#/
        self thread tread_fx_loop( localclientnum );
    }
    else if ( newval == 0 )
    {
/#
        println( "Mark IV Tank Tread FX OFF" );
#/
        self notify( "tread_fx_stop" );
    }
}

flamethrower_fx_loop( localclientnum, str_tag )
{
    self endon( "stop_flamethrower" );
    sndorigin = self gettagorigin( str_tag );
    sndent = spawn( 0, sndorigin, "script_origin" );
    sndent linkto( self, str_tag );
    sndent playsound( 0, "zmb_tank_flame_start" );
    sndent playloopsound( "zmb_tank_flame_loop", 0.6 );
    self thread sndstopflamethrower( sndent );

    while ( true )
    {
        self.flame_fx = playfxontag( localclientnum, level._effect["mech_wpn_flamethrower"], self, str_tag );
        wait 0.2;
    }
}

sndstopflamethrower( ent )
{
    self waittill( "stop_flamethrower" );
    ent playsound( 0, "zmb_tank_flame_stop" );
    ent stoploopsound( 0.25 );
    wait 1;
    ent delete();
}

play_flamethrower_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self notify( "stop_flamethrower" );

    if ( !isdefined( self.sndflame ) )
        self.sndflame = spawn( 0, ( 0, 0, 0 ), "script_origin" );

    if ( newval == 0 )
        return;

    str_tag = "tag_flash";

    switch ( newval )
    {
        case 2:
            str_tag = "tag_flash_gunner1";
            break;
        case 3:
            str_tag = "tag_flash_gunner2";
            break;
        default:
            break;
    }

    self thread flamethrower_fx_loop( localclientnum, str_tag );
}

play_exhaust_fx( localclientnum, is_overheat )
{
    self notify( "stop_exhaust_fx" );
    self endon( "entityshutdown" );
    self endon( "stop_exhaust_fx" );
    fx_id = level._effect["tank_exhaust"];

    if ( is_overheat )
        fx_id = level._effect["tank_overheat"];

    if ( is_overheat )
        self thread sndplayoverheat( self.origin );
    else
        self thread sndplayexhaust();

    while ( true )
    {
        playfxontag( localclientnum, fx_id, self, "tag_origin" );
        wait 0.1;
    }
}

sndplayoverheat( origin )
{
    playloopat( "zmb_bot_timeout_steam", origin );
    self waittill( "stop_exhaust_fx" );
    stoploopat( "zmb_bot_timeout_steam", origin );
}

sndplayexhaust()
{
    origin1 = self gettagorigin( "tag_exhaust_1" );
    ent1 = spawn( 0, origin1, "script_origin" );
    ent1 linkto( self, "tag_exhaust_1" );
    origin2 = self gettagorigin( "tag_exhaust_2" );
    ent2 = spawn( 0, origin2, "script_origin" );
    ent2 linkto( self, "tag_exhaust_2" );
    ent1 playloopsound( "zmb_tank_exhaust_pipe", 1 );
    ent2 playloopsound( "zmb_tank_exhaust_pipe", 1 );
    self waittill( "stop_exhaust_fx" );
    ent1 delete();
    ent2 delete();
}

play_tank_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self notify( "stop_exhaust_fx" );

    if ( isdefined( self.light_fx1 ) )
    {
        stopfx( localclientnum, self.light_fx1 );
        self.light_fx1 = undefined;
    }

    if ( isdefined( self.light_fx2 ) )
    {
        stopfx( localclientnum, self.light_fx2 );
        self.light_fx2 = undefined;
    }

    switch ( newval )
    {
        case 1:
            self thread play_exhaust_fx( localclientnum, 1 );
            self.light_fx1 = playfxontag( localclientnum, level._effect["tank_light_red"], self, "tag_light_left" );
            self.light_fx2 = playfxontag( localclientnum, level._effect["tank_light_red"], self, "tag_light_right" );
            break;
        case 2:
            self.light_fx1 = playfxontag( localclientnum, level._effect["tank_light_grn"], self, "tag_light_left" );
            self.light_fx2 = playfxontag( localclientnum, level._effect["tank_light_grn"], self, "tag_light_right" );
            break;
        case 0:
            self thread play_exhaust_fx( localclientnum, 0 );
            break;
    }
}

tread_fx_loop( localclientnum )
{
    self endon( "tread_fx_stop" );
    self thread sndplaymud();

    while ( true )
    {
        self.tread_fx_left = playfxontag( localclientnum, level._effect["tank_treads"], self, "tag_wheel_back_left" );
        self.tread_fx_right = playfxontag( localclientnum, level._effect["tank_treads"], self, "tag_wheel_back_right" );
        wait 0.5;
    }
}

sndplaymud()
{
    origin3 = self gettagorigin( "tag_wheel_back_left" );
    ent3 = spawn( 0, origin3, "script_origin" );
    ent3 linkto( self, "tag_wheel_back_left" );
    origin4 = self gettagorigin( "tag_wheel_back_right" );
    ent4 = spawn( 0, origin4, "script_origin" );
    ent4 linkto( self, "tag_wheel_back_right" );
    ent3 playloopsound( "zmb_tank_mud_tread", 1 );
    ent4 playloopsound( "zmb_tank_mud_tread", 1 );
    self waittill( "tread_fx_stop" );
    ent3 delete();
    ent4 delete();
}
