// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zombies\_zm_game_mode_objects;

gamemode_common_setup( gametype, location, vision_set, fog_bank )
{
    level thread clientscripts\mp\zombies\_zm_game_mode_objects::init_game_mode_objects( gametype, location );
    players = getlocalplayers();

    if ( gametype == "zstandard" || gametype == "zgrief" )
        return;

    for ( i = 0; i < players.size; i++ )
    {
        localclientnum = players[i] getlocalclientnumber();

        if ( !isdefined( localclientnum ) )
            return;

        visionsetnaked( localclientnum, vision_set, 0 );
        setworldfogactivebank( localclientnum, fog_bank );
    }
}

init_game_mode_objects( mode, location )
{
    level._game_mode_location = location;
    level._game_mode_mode = mode;

    if ( !is_true( level.game_objects_setup ) )
    {
        switch ( level._game_mode_mode )
        {
            case "meat":
            case "race":
            case "zmeat":
            case "zrace":
                players = getlocalplayers();

                for ( i = 0; i < players.size; i++ )
                {
                    trigs = getentarray( i, "vision_trig", "targetname" );

                    foreach ( trig in trigs )
                        trig delete();
                }
        }

        level thread setup_game_mode_objects( mode, location );
        level thread setup_animated_signs();
        level.game_objects_setup = 1;
    }

    if ( level._game_mode_mode == "zrace" || level._game_mode_mode == "race" )
        usealternatereviveicon( 1 );
}

setup_game_mode_objects( mode, location )
{
    level waittill( mode + "_" + location, clientnum );

    if ( clientnum != 0 )
        return;

    spawned = 0;
    structs = getstructarray( "game_mode_object", "targetname" );
    level._game_mode_spawned_objects = [];

    for ( x = 0; x < getlocalplayers().size; x++ )
    {
        for ( i = 0; i < structs.size; i++ )
        {
            if ( !isdefined( structs[i] ) )
                continue;

            if ( !isdefined( structs[i].script_noteworthy ) || structs[i].script_noteworthy != level._game_mode_location )
                continue;

            if ( !structs[i] is_game_mode_object( mode ) )
                continue;

            if ( getactivelocalclients() > 1 )
            {
                if ( isdefined( structs[i].groupname ) && structs[i].groupname == "splitscreen_remove" )
                    continue;
            }

            object = spawn( x, structs[i].origin, "script_model" );

            if ( isdefined( structs[i].angles ) )
                object.angles = structs[i].angles;

            if ( isdefined( structs[i].script_parameters ) )
                object setmodel( structs[i].script_parameters );

            spawned++;
            object.local_owner = x;
            level._game_mode_spawned_objects[level._game_mode_spawned_objects.size] = object;
        }
    }
}

is_game_mode_object( mode )
{
    if ( self.classname == "script_brushmodel" )
        return false;

    if ( !isdefined( self.script_string ) )
        return true;

    if ( issplitscreen() > 1 )
    {
        if ( isdefined( self.groupname ) && self.groupname == "splitscreen_remove" )
            return false;
    }

    tokens = strtok( self.script_string, " " );
    is_object = 0;

    foreach ( token in tokens )
    {
        if ( token == mode )
            is_object = 1;
    }

    if ( is_object )
        return true;

    return false;
}

door_init( team, doornum )
{
    doors = [];
    spots = [];
    signs = [];
    location = getdvar( #"ui_zm_mapstartlocation" );

    for ( i = 0; i < level.struct.size; i++ )
    {
        if ( !isdefined( level.struct[i].name ) )
            continue;

        if ( getactivelocalclients() > 1 )
        {
            if ( isdefined( level.struct[i].groupname ) && level.struct[i].groupname == "splitscreen_remove" )
                continue;
        }

        if ( level.struct[i].name == location + "_" + team + "_door_" + doornum )
        {
            spot = level.struct[i];
            spots[spots.size] = spot;
            players = getlocalplayers();

            for ( x = 0; x < players.size; x++ )
            {
                door = spawn( x, spot.origin, "script_model" );

                if ( isdefined( spot.angles ) )
                    door.angles = spot.angles;

                if ( isdefined( spot.script_parameters ) )
                {
                    door setmodel( spot.script_parameters );
                    door thread door_wobble();
                }

                door._team = team;
                door._door_num = doornum;
                doors[doors.size] = door;
                level._race_doors[level._race_doors.size] = door;
            }
        }

        if ( level.struct[i].name == location + "_" + team + "_arrow_" + doornum )
        {
            spot = level.struct[i];
            players = getlocalplayers();

            for ( x = 0; x < players.size; x++ )
            {
                arrow = spawn( x, spot.origin, "script_model" );

                if ( isdefined( spot.angles ) )
                    arrow.angles = spot.angles;

                if ( isdefined( spot.script_parameters ) )
                    arrow setmodel( spot.script_parameters );

                if ( isdefined( spot.targetname ) )
                    arrow._start_scroll = 1;

                signs[signs.size] = arrow;
                level._race_arrows[level._race_arrows.size] = arrow;
            }
        }
    }

    level thread door_monitor( team, doornum, spots, doors, signs );
    level thread clientscripts\mp\zombies\_zm_game_mode_objects::wobble_game_mode_objects( level._race_arrows );
}

door_monitor( team, doornum, spots, doors, signs )
{
    level endon( "end_race" );

    while ( true )
    {
        if ( signs.size > 0 )
            level thread light_race_arrows( signs );

        level waittill( team + "_" + doornum );
        wait 0.1;

        for ( i = 0; i < doors.size; i++ )
        {
            if ( isdefined( doors[i] ) )
            {
                arrayremovevalue( level._race_doors, doors[i] );
                doors[i] delete();
            }
        }

        doors = [];

        if ( signs.size > 0 )
            level thread blink_race_arrows( signs, team + "_" + doornum );

        if ( !isdefined( spots ) )
            continue;

        level waittill( team + "_" + doornum );
        wait 0.1;

        if ( team == "1" )
            level._team_1_current_door++;
        else
            level._team_2_current_door++;

        for ( x = 0; x < level.localplayers.size; x++ )
        {
            for ( i = 0; i < spots.size; i++ )
            {
                door = spawn( x, spots[i].origin, "script_model" );

                if ( isdefined( spots[i].angles ) )
                    door.angles = spots[i].angles;

                if ( isdefined( spots[i].script_parameters ) )
                {
                    door setmodel( "pb_couch" );
                    door thread door_wobble( x );
                }

                door._localclientnum = x;
                doors[doors.size] = door;
                level._race_doors[level._race_doors.size] = door;
            }
        }

        if ( signs.size > 0 )
            level thread dim_race_arrows( signs );

        break;
    }
}

door_wobble( localclientnumber )
{
    level endon( "end_race" );
    og_angles = self.angles;
    og_origin = self.origin;

    while ( isdefined( self ) )
    {
        self rotateto( og_angles + ( randomfloatrange( -5, 5 ), randomfloatrange( -5, 5 ), randomfloatrange( -5, 5 ) ), 5, 1 );
        wait 5;
    }
}

clean_up_doors_and_signs_on_race_end()
{
    level waittill( "end_race" );
    wait 3;
    deleted = 0;

    if ( !isdefined( level._race_doors ) )
        return;

    for ( i = 0; i < level._race_doors.size; i++ )
    {
        if ( isdefined( level._race_doors[i] ) )
        {
            if ( isdefined( level._race_doors[i]._progress_fx ) )
                stopfx( level._race_doors[i]._localclientnum, level._race_doors[i]._progress_fx );

            level._race_doors[i] delete();
            deleted++;
        }
    }

    for ( i = 0; i < level._race_arrows.size; i++ )
    {
        if ( isdefined( level._race_arrows[i] ) )
        {
            level._race_arrows[i] delete();
            deleted++;
        }
    }

    level notify( "do_cleanup" );
}

set_arrow_model( arrows, model )
{
    for ( i = 0; i < arrows.size; i++ )
    {
        arrows[i] setmodel( model );

        if ( model == "p6_zm_sign_neon_arrow_on_green" )
            arrows[i] playsound( 0, "zmb_arrow_buzz" );
    }
}

light_race_arrows( arrows )
{
    set_arrow_model( arrows, "p6_zm_sign_neon_arrow_on_red" );
}

dim_race_arrows( arrows )
{
    set_arrow_model( arrows, "p6_zm_sign_neon_arrow_off" );
}

blink_race_arrows( arrows, end_on )
{
    level endon( "end_race" );
    wait 0.1;
    level endon( end_on );

    while ( true )
    {
        set_arrow_model( arrows, "p6_zm_sign_neon_arrow_on_green" );
        wait( randomfloatrange( 0.1, 0.25 ) );
        set_arrow_model( arrows, "p6_zm_sign_neon_arrow_off" );
        wait( randomfloatrange( 0.1, 0.25 ) );
    }
}

zombie_soul_runner( localclientnum, fx_name, dest )
{
    if ( !isdefined( level.current_soul_runners ) )
        level.current_soul_runners = 0;

    if ( level.current_soul_runners > 12 )
        return;

    level.current_soul_runners++;
    playfxontag( localclientnum, level._effect[fx_name], self, "tag_origin" );
    playsound( 0, "zmb_souls_start", self.origin );
    self playloopsound( "zmb_souls_loop", 0.75 );
    dist = distance( dest.origin, self.origin );
    time = dist / 700;
    self moveto( dest.origin, time );
    self waittill( "movedone" );

    while ( isdefined( dest ) && isdefined( dest.target ) )
    {
        new_dest = getstruct( dest.target, "targetname" );
        dest = new_dest;
        dist = distance( new_dest.origin, self.origin );
        time = dist / 700;
        self moveto( new_dest.origin, time );
        self waittill( "movedone" );
    }

    playsound( 0, "zmb_souls_end", self.origin );
    self delete();
    level.current_soul_runners--;
}

team_1_zombie_release_soul( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    door = get_closest_team_door( "1", self );
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( !isdefined( door ) )
        {
            playfx( i, level._effect["zomb_gib"], self.origin );
            continue;
        }

        e = spawn( i, self.origin + vectorscale( ( 0, 0, 1 ), 40.0 ), "script_model" );
        e setmodel( "tag_origin" );
        e thread zombie_soul_runner( i, "race_soul_trail", door );
    }
}

team_2_zombie_release_soul( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    door = get_closest_team_door( "2", self );
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( !isdefined( door ) )
        {
            playfx( i, level._effect["zomb_gib"], self.origin );
            continue;
        }

        e = spawn( i, self.origin + vectorscale( ( 0, 0, 1 ), 40.0 ), "script_model" );
        e setmodel( "tag_origin" );
        e thread zombie_soul_runner( i, "race_soul_trail", door );
    }
}

team_1_zombie_release_grief_soul( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    door = get_closest_team_door( "1", self );
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( !isdefined( door ) )
        {
            playfx( i, level._effect["zomb_gib"], self.origin );
            continue;
        }

        e = spawn( i, self.origin + vectorscale( ( 0, 0, 1 ), 40.0 ), "script_model" );
        e setmodel( "tag_origin" );
        e thread zombie_soul_runner( i, "race_soul_trail_green", door );
    }
}

team_2_zombie_release_grief_soul( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    door = get_closest_team_door( "2", self );
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( !isdefined( door ) )
        {
            playfx( i, level._effect["zomb_gib"], self.origin );
            continue;
        }

        e = spawn( i, self.origin + vectorscale( ( 0, 0, 1 ), 40.0 ), "script_model" );
        e setmodel( "tag_origin" );
        e thread zombie_soul_runner( i, "race_soul_trail_green", door );
    }
}

get_closest_team_door( team, zombie )
{
    current_door = level._team_1_current_door;

    if ( team == "2" )
        current_door = level._team_2_current_door;

    potential_doors = [];

    for ( i = 0; i < level._race_doors.size; i++ )
    {
        if ( isdefined( level._race_doors[i] ) && isdefined( level._race_doors[i]._team ) && level._race_doors[i]._team == team && level._race_doors[i]._door_num == current_door )
            potential_doors[potential_doors.size] = level._race_doors[i];
    }

    if ( potential_doors.size > 0 )
    {
        closest_soul_runner_spot = soul_runner_test( zombie, team );

        if ( isdefined( closest_soul_runner_spot ) )
            return closest_soul_runner_spot;

        return random( potential_doors );
    }

    return undefined;
}

soul_runner_test( zombie, team )
{
    if ( !isdefined( zombie ) )
        return undefined;

    points = getstructarray( "soul_path_" + team, "script_noteworthy" );

    if ( points.size < 1 )
        return undefined;

    org = zombie.origin;
    struct_closest = undefined;
    farthest_dist = 160000;

    for ( i = 0; i < points.size; i++ )
    {
        curr_dist = distancesquared( points[i].origin, org );

        if ( curr_dist < farthest_dist && points[i].origin[2] > org[2] )
        {
            farthest_dist = curr_dist;
            struct_closest = points[i];
        }
    }

    return struct_closest;
}

setup_animated_signs()
{
    wait 1;
    localplayers = getlocalplayers();
    structs = getstructarray( "game_mode_object", "targetname" );

    for ( i = 0; i < structs.size; i++ )
    {
        if ( !isdefined( structs[i] ) )
            continue;

        if ( !isdefined( structs[i].script_noteworthy ) || structs[i].script_noteworthy != level._game_mode_location )
            continue;

        if ( !structs[i] is_game_mode_object( level._game_mode_mode ) )
            continue;

        if ( issubstr( structs[i].script_parameters, "sign_encounters" ) )
        {
            animated_panels = [];

            for ( x = 0; x < localplayers.size; x++ )
            {
                animated_panel = spawn( x, structs[i].origin, "script_model" );
                animated_panel.angles = structs[i].angles;
                animated_panel.origin = structs[i].origin;
                animated_panel thread animate_sign();
            }
        }
    }
}

animate_sign( animated_panels )
{
    self endon( "death" );
    mode = "";

    if ( level._game_mode_mode == "meat" || level._game_mode_mode == "zmeat" )
        mode = "meat";

    if ( level._game_mode_mode == "race" || level._game_mode_mode == "zrace" )
        mode = "race";

    sign_variant = 1;

    while ( true )
    {
        for ( i = 1; i < 5; i++ )
        {
            self setmodel( "p6_zm_sign_" + mode + "_0" + sign_variant + "_step" + i );
            wait( randomfloatrange( 0.75, 1.5 ) );
        }

        wait( randomfloatrange( 0.75, 1.5 ) );
    }
}

wobble_game_mode_objects( objects )
{
    level endon( "end_game" );
    level waittill( level._game_mode_mode + "_" + level._game_mode_location, clientnum );

    if ( clientnum != 0 )
        return;

    wait 2;

    while ( true )
    {
        foreach ( object in objects )
        {
            if ( !isdefined( object.og_org ) )
            {
                object.og_org = object.origin;
                object.og_ang = object.angles;
            }

            object rotateto( object.og_ang + ( randomfloatrange( -5, 5 ), randomfloatrange( -5, 5 ), randomfloatrange( -5, 5 ) ), 3 );
        }

        wait 3;
    }
}
