// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zombies\_zm_ai_screecher;
#include clientscripts\mp\zombies\_zm_ai_avogadro;
#include clientscripts\mp\zm_transit_buildables;
#include clientscripts\mp\_visionset_mgr;

precache()
{
    level thread clientscripts\mp\zombies\_zm_ai_screecher::precache();
    level thread clientscripts\mp\zombies\_zm_ai_avogadro::precache();
}

premain()
{
    level thread clientscripts\mp\zombies\_zm_ai_screecher::init();
    level thread clientscripts\mp\zombies\_zm_ai_avogadro::init();
    clientscripts\mp\zm_transit_buildables::include_buildables();
    clientscripts\mp\zm_transit_buildables::init_buildables();
    clientscripts\mp\_visionset_mgr::vsmgr_register_visionset_info( "zm_power_high_low", 1, 7, "zm_transit_power_int_off", "zm_transit_power_int_fluctuate" );
}

main()
{
    level thread sidequest_complete_watch();
    level thread sidequest_complete_pyramid_watch();
}

sidequest_complete_watch()
{
    while ( true )
    {
        event = level waittill_any_return( "sqm", "sqmc", "sqr", "sqrc" );

        if ( event == "sqm" || event == "sqmc" )
        {
            skiprunners = level.sqm_fx;
            level.sqm_fx = 1;
            level thread sidequest_complete_fx( "maxis", skiprunners );
        }
        else if ( ( event == "sqr" || event == "sqrc" ) && !is_true( level.sqr_fx ) )
        {
            skiprunners = level.sqr_fx;
            level.sqr_fx = 1;
            level thread sidequest_complete_fx( "richtofen", skiprunners );
        }
    }
}

sidequest_complete_fx( story, skiprunners )
{
    level endon( "sq_kfx" );
    electric_structs = getstructarray( "sq_common_pole_fx", "targetname" );
    electric_struct = getstruct( "sq_common_tower_fx", "targetname" );
    players = getlocalplayers();

    if ( isdefined( electric_struct ) )
        level thread sidequest_complete_fx_lightning( electric_struct );

    if ( isdefined( electric_structs ) && !is_true( skiprunners ) )
    {
        while ( true )
        {
            foreach ( struct in electric_structs )
            {
                thread sidequest_complete_fx_runner( story, struct );
                wait( randomfloatrange( 0.5, 1 ) );
            }

            wait( randomintrange( 3, 9 ) );
        }
    }
}

sidequest_complete_fx_lightning( electric_struct )
{
    level notify( "sqkl" );
    level endon( "sqkl" );

    while ( true )
    {
        players = getlocalplayers();

        foreach ( clientnum, player in players )
            playfx( clientnum, level._effect["sq_common_lightning"], electric_struct.origin - vectorscale( ( 0, 0, 1 ), 768.0 ) );

        wait( randomfloatrange( 1, 2 ) );
    }
}

sidequest_complete_pyramid_watch()
{
    electric_struct = getstruct( "sq_common_tower_fx", "targetname" );

    while ( true )
    {
        event = level waittill_any_return8( "zsd", "zsf", "zsb", "zsbd", "zsbt", "zsh", "zsp", "zsc" );
        story = level waittill_any_return( "sq_max", "sq_rich" );

        if ( story == "sq_max" )
            story = "maxis";
        else
            story = "richtofen";

        level thread sidequest_complete_fx_triangle_runner( story, event, electric_struct );
    }
}

sidequest_complete_fx_triangle_runner( story, event, end_struct )
{
    screech_struct = get_screecher_zone( event );
    level endon( "sq_kmt" );
    level endon( "sq_krt" );

    while ( true )
    {
        players = getlocalplayers();
        fxrunners = [];

        foreach ( index, client in players )
        {
            fxrunners[index] = spawn( index, screech_struct.origin + vectorscale( ( 0, 0, 1 ), 140.0 ), "script_model" );
            fxrunners[index] setmodel( "tag_origin" );
            wait 0.05;
            playfxontag( index, level._effect[story + "_sparks"], fxrunners[index], "tag_origin" );
        }

        foreach ( runner in fxrunners )
        {
            runner thread sidequest_complete_fx_runner_move_origins( screech_struct.origin + vectorscale( ( 0, 0, 1 ), 100.0 ), end_struct.origin );
            wait( randomfloatrange( 1, 3 ) );
        }

        wait( randomintrange( 5, 9 ) );
    }
}

sidequest_complete_fx_runner_move_origins( origin1, origin2 )
{
    if ( isdefined( origin1 ) )
    {
        self moveto( origin1, 1.4 );
        self waittill( "movedone" );
    }

    if ( isdefined( origin2 ) )
    {
        self moveto( origin2, 1.4 );
        self waittill( "movedone" );
    }

    self delete();
}

sidequest_complete_fx_runner( story, struct )
{
    players = getlocalplayers();
    fxrunners = [];

    foreach ( index, client in players )
    {
        fxrunners[index] = spawn( index, struct.origin, "script_model" );
        fxrunners[index] setmodel( "tag_origin" );
        wait 0.1;
        playfxontag( index, level._effect[story + "_sparks"], fxrunners[index], "tag_origin" );
        fxrunners[index] thread sidequest_complete_fx_runner_move( struct );
        wait 0.1;
    }
}

sidequest_complete_fx_runner_move( struct )
{
    while ( isdefined( struct.target ) )
    {
        struct = getstruct( struct.target, "targetname" );
        self moveto( struct.origin, 1.4 );
        self waittill( "movedone" );
    }

    if ( isdefined( self ) )
        self delete();
}

get_screecher_zone( str )
{
    key = "";

    switch ( str )
    {
        case "zsc":
            key = "cornfield";
            break;
        case "zsd":
            key = "diner";
            break;
        case "zsf":
            key = "forest";
            break;
        case "zsb":
            key = "busdepot";
            break;
        case "zsbd":
            key = "bridgedepot";
            break;
        case "zsbt":
            key = "townbridge";
            break;
        case "zsh":
            key = "huntershack";
            break;
        case "zsp":
            key = "powerstation";
            break;
    }

    structs = getstructarray( "screecher_escape", "targetname" );

    for ( x = 0; x < structs.size; x++ )
    {
        if ( isdefined( structs[x].script_noteworthy ) && structs[x].script_noteworthy == key )
            return structs[x];
    }
}

waittill_any_return8( string1, string2, string3, string4, string5, string6, string7, string8 )
{
    if ( ( !isdefined( string1 ) || string1 != "death" ) && ( !isdefined( string2 ) || string2 != "death" ) && ( !isdefined( string3 ) || string3 != "death" ) && ( !isdefined( string4 ) || string4 != "death" ) && ( !isdefined( string5 ) || string5 != "death" ) && ( !isdefined( string6 ) || string6 != "death" ) && ( !isdefined( string7 ) || string7 != "death" ) && ( !isdefined( string8 ) || string8 != "death" ) )
        self endon( "death" );

    ent = spawnstruct();

    if ( isdefined( string1 ) )
        self thread waittill_string( string1, ent );

    if ( isdefined( string2 ) )
        self thread waittill_string( string2, ent );

    if ( isdefined( string3 ) )
        self thread waittill_string( string3, ent );

    if ( isdefined( string4 ) )
        self thread waittill_string( string4, ent );

    if ( isdefined( string5 ) )
        self thread waittill_string( string5, ent );

    if ( isdefined( string6 ) )
        self thread waittill_string( string6, ent );

    if ( isdefined( string7 ) )
        self thread waittill_string( string7, ent );

    if ( isdefined( string8 ) )
        self thread waittill_string( string8, ent );

    ent waittill( "returned", msg );
    ent notify( "die" );
    return msg;
}
