// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;

main()
{
    registerclientfield( "toplayer", "tazered", 1000, 1, "int", ::updateplayertazered, 0 );
    level._effect["prox_grenade_friendly_default"] = loadfx( "weapon/grenade/fx_prox_grenade_scan_grn" );
    level._effect["prox_grenade_friendly_warning"] = loadfx( "weapon/grenade/fx_prox_grenade_wrn_grn" );
    level._effect["prox_grenade_enemy_default"] = loadfx( "weapon/grenade/fx_prox_grenade_scan_red" );
    level._effect["prox_grenade_enemy_warning"] = loadfx( "weapon/grenade/fx_prox_grenade_wrn_red" );
    level._effect["prox_grenade_player_shock"] = loadfx( "weapon/grenade/fx_prox_grenade_impact_player_spwner" );
}

spawned( localclientnum )
{
    if ( self isgrenadedud() )
        return;

    self thread proxygrenadefx( localclientnum );
}

updateplayertazered( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{

}

proxygrenadefx( localclientnum )
{
    self endon( "entityshutdown" );
    level endon( "player_switch" );
    self waittill_dobj( localclientnum );
    waittillsnapprocessed( localclientnum );
    fx_handle = self playflarefx( localclientnum );
    self notify( "teamBased_fx_reinitialized" );
    self thread checkforplayerswitch( localclientnum, fx_handle );
    level thread watchforplayerrespawnforteambasedfx( localclientnum, self, ::proxygrenadefx, fx_handle );
}

playflarefx( localclientnum )
{
    self endon( "entityshutdown" );
    level endon( "player_switch" );

    if ( friendnotfoe( localclientnum ) )
        fx_handle = playfxontag( localclientnum, level._effect["prox_grenade_friendly_default"], self, "tag_fx" );
    else
        fx_handle = playfxontag( localclientnum, level._effect["prox_grenade_enemy_default"], self, "tag_fx" );

    self thread watchproxyshutdown( localclientnum, fx_handle );
    return fx_handle;
}

watchproxyshutdown( localclientnum, fxhandle )
{
    msg = self waittill_any_return( "entityshutdown", "team_changed", "player_switch" );
    stopfx( localclientnum, fxhandle );

    if ( msg == "team_changed" )
        self thread proxygrenadefx( localclientnum );
}

checkforplayerswitch( localclientnum, fxhandle )
{
    self endon( "entityshutdown" );
    self endon( "teamBased_fx_reinitialized" );
    level waittill( "player_switch" );
    self notify( "player_switch" );

    if ( isdefined( fxhandle ) )
        stopfx( localclientnum, fxhandle );

    waittillframeend;
    self thread proxygrenadefx( localclientnum );
}

taserhudfx( localclientnum, position )
{
    self endon( "entityshutdown" );
    level endon( "respawn" );

    if ( self isremotecontrolling() )
        return;

    trace = bullettrace( getlocalclienteyepos( localclientnum ), position, 0, self );

    if ( trace["fraction"] >= 1 )
    {
        if ( self hasperk( localclientnum, "specialty_proximityprotection" ) )
            self thread reducedshock( localclientnum, position );
        else
        {
            self thread flickervisionset( localclientnum, 0.03, 1.25, 0.0 );
            cycles = 3;

            for ( i = 0; i < 2; i++ )
            {
                zap_wait = 0.25;

                for ( j = 0; j < cycles; j++ )
                {
                    if ( getclientfieldtoplayer( "tazered" ) == 1 )
                    {
                        menuname = "fullscreen_proximity";
                        forwardvec = vectornormalize( anglestoforward( self.angles ) );
                        rightvec = vectornormalize( anglestoright( self.angles ) );
                        explosionvec = vectornormalize( position - self.origin );
                        fdot = vectordot( explosionvec, forwardvec );
                        rdot = vectordot( explosionvec, rightvec );

                        if ( abs( fdot ) > abs( rdot ) )
                        {
                            if ( fdot > 0 )
                                menustate = "proximity_vertical_top" + j;
                            else
                                menustate = "proximity_vertical_bottom" + j;
                        }
                        else if ( rdot > 0 )
                            menustate = "proximity_horizontal_right" + j;
                        else
                            menustate = "proximity_horizontal_left" + j;

                        animateui( localclientnum, menuname, menustate, "in", 0 );
                    }

                    wait( zap_wait );
                    zap_wait = zap_wait / 2;
                }

                wait 0.2;
                cycles--;
            }
        }
    }
}

reducedshock( localclientnum, position )
{
    self endon( "entityshutdown" );
    level endon( "respawn" );
    menuname = "fullscreen_proximity";
    self thread flickervisionset( localclientnum, 0.03, 0.15, 0.0 );
    self playsound( 0, "wpn_taser_mine_tacmask" );
    forwardvec = vectornormalize( anglestoforward( self.angles ) );
    rightvec = vectornormalize( anglestoright( self.angles ) );
    explosionvec = vectornormalize( position - self.origin );
    fdot = vectordot( explosionvec, forwardvec );
    rdot = vectordot( explosionvec, rightvec );

    if ( abs( fdot ) > abs( rdot ) )
    {
        if ( fdot > 0 )
            menustate = "proximity_vertical_top0";
        else
            menustate = "proximity_vertical_bottom0";
    }
    else if ( rdot > 0 )
        menustate = "proximity_horizontal_right0";
    else
        menustate = "proximity_horizontal_left0";

    animateui( localclientnum, menuname, menustate, "in", 0 );
}

flickervisionset( localclientnum, period, duration_seconds, transition )
{
    level endon( "respawn" );
    flicker_start_time = getrealtime();
    saved_vision = getvisionsetnaked( localclientnum );
    toggle = 1;
    duration_ms = duration_seconds * 1000;
    wait 0.1;

    while ( true )
    {
        if ( getrealtime() > flicker_start_time + duration_ms )
            break;

        if ( toggle )
            visionsetnaked( localclientnum, "taser_mine_shock", transition );
        else
            visionsetnaked( localclientnum, saved_vision, transition );

        toggle = !toggle;
        wait( period );
    }

    visionsetnaked( localclientnum, saved_vision, transition );
}

visionsettoggle( localclientnum, toggle )
{
    duration = 0.05;

    if ( toggle )
        visionsetnaked( localclientnum, "taser_mine_shock", duration );
    else
        visionsetnaked( localclientnum, getdvar( #"mapname" ), duration );

    return !toggle;
}
