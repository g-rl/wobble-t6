// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_utility;

init()
{
    if ( level.createfx_enabled )
        return;

    level.vsmgr_initializing = 1;
    level.vsmgr_default_info_name = "none";
    level.vsmgr = [];
    level.vsmgr_states_inited = [];
    level.vsmgr_filter_custom_enable = [];
    level thread register_type( "visionset", ::visionset_slot_cb, ::visionset_lerp_cb, ::visionset_update_cb );
    vsmgr_register_visionset_info( level.vsmgr_default_info_name, 1, 1, "undefined", "undefined" );
    level thread register_type( "overlay", ::overlay_slot_cb, ::overlay_lerp_cb, ::overlay_update_cb );
    vsmgr_register_overlay_info_style_none( level.vsmgr_default_info_name, 1, 1 );
    level.vsmgr_is_type_currently_default_func = ::vsmgr_is_type_currently_default;
    [[ level.on_finalize_initialization_callback ]]( ::finalize_clientfields );
    level thread monitor();
}

vsmgr_register_visionset_info( name, version, lerp_step_count, visionset_from, visionset_to )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "visionset", name, version, lerp_step_count ) )
        return;

    level.vsmgr["visionset"].info[name].visionset_from = visionset_from;
    level.vsmgr["visionset"].info[name].visionset_to = visionset_to;
}

vsmgr_register_overlay_info_style_none( name, version, lerp_step_count )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "overlay", name, version, lerp_step_count ) )
        return;

    level.vsmgr["overlay"].info[name].style = 0;
}

vsmgr_register_overlay_info_style_filter( name, version, lerp_step_count, filter_index, pass_index, material_name, constant_index )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "overlay", name, version, lerp_step_count ) )
        return;

    level.vsmgr["overlay"].info[name].style = 1;
    level.vsmgr["overlay"].info[name].filter_index = filter_index;
    level.vsmgr["overlay"].info[name].pass_index = pass_index;
    level.vsmgr["overlay"].info[name].material_name = material_name;
    level.vsmgr["overlay"].info[name].constant_index = constant_index;
}

vsmgr_register_overlay_info_style_blur( name, version, lerp_step_count, transition_in, transition_out, magnitude )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "overlay", name, version, lerp_step_count ) )
        return;

    level.vsmgr["overlay"].info[name].style = 2;
    level.vsmgr["overlay"].info[name].transition_in = transition_in;
    level.vsmgr["overlay"].info[name].transition_out = transition_out;
    level.vsmgr["overlay"].info[name].magnitude = magnitude;
}

vsmgr_register_overlay_info_style_electrified( name, version, lerp_step_count, duration )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "overlay", name, version, lerp_step_count ) )
        return;

    level.vsmgr["overlay"].info[name].style = 3;
    level.vsmgr["overlay"].info[name].duration = duration;
}

vsmgr_register_overlay_info_style_poison( name, version, lerp_step_count )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "overlay", name, version, lerp_step_count ) )
        return;

    level.vsmgr["overlay"].info[name].style = 5;
}

vsmgr_register_overlay_info_style_burn( name, version, lerp_step_count, duration )
{
    if ( level.createfx_enabled )
        return;

    if ( !register_info( "overlay", name, version, lerp_step_count ) )
        return;

    level.vsmgr["overlay"].info[name].style = 4;
    level.vsmgr["overlay"].info[name].duration = duration;
}

vsmgr_is_type_currently_default( localclientnum, type )
{
    if ( !level.vsmgr[type].in_use )
        return true;

    state = get_state( localclientnum, type );
    curr_info = get_info( type, state.curr_slot );
    return curr_info.name == level.vsmgr_default_info_name;
}

register_type( type, cf_slot_cb, cf_lerp_cb, update_cb )
{
    level.vsmgr[type] = spawnstruct();
    level.vsmgr[type].type = type;
    level.vsmgr[type].in_use = 0;
    level.vsmgr[type].highest_version = 0;
    level.vsmgr[type].server_version = getserverhighestclientfieldversion();
    level.vsmgr[type].cf_slot_name = type + "_slot";
    level.vsmgr[type].cf_lerp_name = type + "_lerp";
    level.vsmgr[type].cf_slot_cb = cf_slot_cb;
    level.vsmgr[type].cf_lerp_cb = cf_lerp_cb;
    level.vsmgr[type].update_cb = update_cb;
    level.vsmgr[type].info = [];
    level.vsmgr[type].sorted_name_keys = [];
}

finalize_clientfields()
{
    typekeys = getarraykeys( level.vsmgr );

    for ( type_index = 0; type_index < typekeys.size; type_index++ )
        level.vsmgr[typekeys[type_index]] thread finalize_type_clientfields();

    level.vsmgr_initializing = 0;
}

init_fogvols()
{
    while ( !isdefined( level._fogvols_inited ) )
        wait 0.1;

    level thread fog_vol_to_visionset_monitor();
    level thread reset_player_fv2vs_infos_on_respawn();
}

finalize_type_clientfields()
{
    if ( 1 >= self.info.size )
    {
        level thread init_fogvols();
        return;
    }

    self.in_use = 1;
    self.cf_slot_bit_count = getminbitcountfornum( self.info.size - 1 );
    self.cf_lerp_bit_count = self.info[self.sorted_name_keys[0]].lerp_bit_count;

    for ( i = 0; i < self.sorted_name_keys.size; i++ )
    {
        self.info[self.sorted_name_keys[i]].slot_index = i;

        if ( self.info[self.sorted_name_keys[i]].lerp_bit_count > self.cf_lerp_bit_count )
            self.cf_lerp_bit_count = self.info[self.sorted_name_keys[i]].lerp_bit_count;
    }

    registerclientfield( "toplayer", self.cf_slot_name, self.highest_version, self.cf_slot_bit_count, "int", self.cf_slot_cb, 0, 1 );

    if ( 1 < self.cf_lerp_bit_count )
        registerclientfield( "toplayer", self.cf_lerp_name, self.highest_version, self.cf_lerp_bit_count, "float", self.cf_lerp_cb, 0, 1 );
}

validate_info( type, name, version )
{
    keys = getarraykeys( level.vsmgr );

    for ( i = 0; i < keys.size; i++ )
    {
        if ( type == keys[i] )
            break;
    }

    assert( i < keys.size, "In visionset_mgr, type '" + type + "'is unknown" );

    if ( version > level.vsmgr[type].server_version )
        return false;

    if ( isdefined( level.vsmgr[type].info[name] ) && version < level.vsmgr[type].info[name].version )
    {
        if ( version < level.vsmgr[type].info[name].version )
            return false;

        level.vsmgr[type].info[name] = undefined;
    }

    return true;
}

add_sorted_name_key( type, name )
{
    for ( i = 0; i < level.vsmgr[type].sorted_name_keys.size; i++ )
    {
        if ( name < level.vsmgr[type].sorted_name_keys[i] )
            break;
    }

    arrayinsert( level.vsmgr[type].sorted_name_keys, name, i );
}

add_info( type, name, version, lerp_step_count )
{
    self.type = type;
    self.name = name;
    self.version = version;
    self.lerp_step_count = lerp_step_count;
    self.lerp_bit_count = getminbitcountfornum( lerp_step_count );
}

register_info( type, name, version, lerp_step_count )
{
    assert( level.vsmgr_initializing, "All info registration in the visionset_mgr system must occur during the first frame while the system is initializing" );
    lower_name = tolower( name );

    if ( !validate_info( type, lower_name, version ) )
        return false;

    add_sorted_name_key( type, lower_name );
    level.vsmgr[type].info[lower_name] = spawnstruct();
    level.vsmgr[type].info[lower_name] add_info( type, lower_name, version, lerp_step_count );

    if ( version > level.vsmgr[type].highest_version )
        level.vsmgr[type].highest_version = version;

    return true;
}

slot_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump, type )
{
    init_states( localclientnum );
    level.vsmgr[type].state[localclientnum].curr_slot = newval;

    if ( bnewent || binitialsnap )
        level.vsmgr[type].state[localclientnum].force_update = 1;
}

visionset_slot_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self slot_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump, "visionset" );
}

overlay_slot_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self slot_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump, "overlay" );
}

lerp_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump, type )
{
    init_states( localclientnum );
    level.vsmgr[type].state[localclientnum].curr_lerp = newval;

    if ( bnewent || binitialsnap )
        level.vsmgr[type].state[localclientnum].force_update = 1;
}

visionset_lerp_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self lerp_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump, "visionset" );
}

overlay_lerp_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self lerp_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump, "overlay" );
}

get_info( type, slot )
{
    return level.vsmgr[type].info[level.vsmgr[type].sorted_name_keys[slot]];
}

get_state( localclientnum, type )
{
    return level.vsmgr[type].state[localclientnum];
}

should_update_state()
{
    return self.force_update || self.prev_slot != self.curr_slot || self.prev_lerp != self.curr_lerp;
}

transition_state()
{
    self.prev_slot = self.curr_slot;
    self.prev_lerp = self.curr_lerp;
    self.force_update = 0;
}

init_states( localclientnum )
{
    if ( isdefined( level.vsmgr_states_inited[localclientnum] ) )
        return;

    typekeys = getarraykeys( level.vsmgr );

    for ( type_index = 0; type_index < typekeys.size; type_index++ )
    {
        type = typekeys[type_index];

        if ( !level.vsmgr[type].in_use )
            continue;

        if ( !isdefined( level.vsmgr[type].state ) )
            level.vsmgr[type].state = [];

        level.vsmgr[type].state[localclientnum] = spawnstruct();
        level.vsmgr[type].state[localclientnum].prev_slot = level.vsmgr[type].info[level.vsmgr_default_info_name].slot_index;
        level.vsmgr[type].state[localclientnum].curr_slot = level.vsmgr[type].info[level.vsmgr_default_info_name].slot_index;
        level.vsmgr[type].state[localclientnum].prev_lerp = 1;
        level.vsmgr[type].state[localclientnum].curr_lerp = 1;
        level.vsmgr[type].state[localclientnum].force_update = 0;
    }

    level.vsmgr_states_inited[localclientnum] = 1;
}

demo_jump_monitor()
{
    if ( !level.isdemoplaying )
        return;

    typekeys = getarraykeys( level.vsmgr );
    oldlerps = [];

    while ( true )
    {
        level waittill_any( "demo_jump", "demo_player_switch", "visionset_mgr_reset" );

        for ( type_index = 0; type_index < typekeys.size; type_index++ )
        {
            type = typekeys[type_index];

            if ( !level.vsmgr[type].in_use )
                continue;

/#

#/
            level.vsmgr[type].state[0].force_update = 1;
        }
    }
}

demo_spectate_monitor()
{
    if ( !level.isdemoplaying )
        return;

    typekeys = getarraykeys( level.vsmgr );

    while ( true )
    {
        if ( isspectating( 0, 0 ) )
        {
            if ( !is_true( level.vsmgr_is_spectating ) )
            {
                visionsetnaked( 0, "default", 0 );
                level notify( "visionset_mgr_reset" );
            }

            level.vsmgr_is_spectating = 1;
        }
        else
        {
            if ( is_true( level.vsmgr_is_spectating ) )
                level notify( "visionset_mgr_reset" );

            level.vsmgr_is_spectating = 0;
        }

        wait 0.016;
    }
}

monitor()
{
    while ( level.vsmgr_initializing )
        wait 0.01;

    if ( level.isdemoplaying )
    {
        level thread demo_spectate_monitor();
        level thread demo_jump_monitor();
    }

    typekeys = getarraykeys( level.vsmgr );

    while ( true )
    {
        for ( type_index = 0; type_index < typekeys.size; type_index++ )
        {
            type = typekeys[type_index];

            if ( !level.vsmgr[type].in_use )
                continue;

            for ( localclientnum = 0; localclientnum < level.localplayers.size; localclientnum++ )
            {
                init_states( localclientnum );

                if ( level.vsmgr[type].state[localclientnum] should_update_state() )
                {
/#

#/
                    level.vsmgr[type] thread [[ level.vsmgr[type].update_cb ]]( localclientnum, type );
                    level.vsmgr[type].state[localclientnum] transition_state();
                }
            }
        }

        wait 0.01;
    }
}

visionset_update_cb( localclientnum, type )
{
    state = get_state( localclientnum, type );
    curr_info = get_info( type, state.curr_slot );
    prev_info = get_info( type, state.prev_slot );
/#

#/

    if ( is_true( level.isdemoplaying ) && isspectating( localclientnum, 1 ) )
        return;

    if ( level.vsmgr_default_info_name == curr_info.name )
    {
        level notify( "vsionset_mgr_incontrol" );
        init_fog_vol_to_visionset_monitor( level._fv2vs_default_visionset, level._fv2vs_default_trans_in, 1 );
        level thread fog_vol_to_visionset_monitor();
        level thread reset_player_fv2vs_infos_on_respawn();
        level notify( "visionset_manager_none_state" );
        return;
    }

    level notify( "vsionset_mgr_incontrol" );
    visionsetnakedlerp( localclientnum, curr_info.visionset_from, curr_info.visionset_to, state.curr_lerp );
}

set_poison_overlay( amount )
{
    setdvar( "r_poisonFX_debug_enable", 1 );
    setdvarfloat( "r_poisonFX_pulse", 2 );
    setdvarfloat( "r_poisonFX_warpX", -0.3 );
    setdvarfloat( "r_poisonFX_warpY", 0.15 );
    setdvarfloat( "r_poisonFX_dvisionA", 0 );
    setdvarfloat( "r_poisonFX_dvisionX", 0 );
    setdvarfloat( "r_poisonFX_dvisionY", 0 );
    setdvarfloat( "r_poisonFX_blurMin", 0 );
    setdvarfloat( "r_poisonFX_blurMax", 3 );
    setdvarfloat( "r_poisonFX_debug_amount", amount );
}

clear_poison_overlay()
{
    setdvarfloat( "r_poisonFX_debug_amount", 0 );
    setdvar( "r_poisonFX_debug_enable", 0 );
}

overlay_update_cb( localclientnum, type )
{
    state = get_state( localclientnum, type );
    curr_info = get_info( type, state.curr_slot );
    prev_info = get_info( type, state.prev_slot );
/#

#/

    if ( state.force_update || state.prev_slot != state.curr_slot )
    {
        switch ( prev_info.style )
        {
            case 0:
                break;
            case 1:
                level.localplayers[localclientnum] set_filter_pass_enabled( prev_info.filter_index, prev_info.pass_index, 0 );
                break;
            case 2:
                setblurbylocalclientnum( localclientnum, 0, prev_info.transition_out );
                break;
            case 3:
                setelectrified( localclientnum, 0 );
                break;
            case 4:
                setburn( localclientnum, 0 );
                break;
            case 5:
                clear_poison_overlay();
                break;
        }
    }

    if ( is_true( level.isdemoplaying ) && isspectating( localclientnum, 0 ) )
        return;

    switch ( curr_info.style )
    {
        case 0:
            break;
        case 1:
            if ( state.force_update || state.prev_slot != state.curr_slot || state.prev_lerp != state.curr_lerp )
            {
                if ( isdefined( level.vsmgr_filter_custom_enable[curr_info.material_name] ) )
                    level.localplayers[localclientnum] [[ level.vsmgr_filter_custom_enable[curr_info.material_name] ]]( curr_info );
                else
                {
                    level.localplayers[localclientnum] set_filter_pass_material( curr_info.filter_index, curr_info.pass_index, level.filter_matid[curr_info.material_name] );
                    level.localplayers[localclientnum] set_filter_pass_enabled( curr_info.filter_index, curr_info.pass_index, 1 );

                    if ( isdefined( curr_info.constant_index ) )
                        level.localplayers[localclientnum] set_filter_pass_constant( curr_info.filter_index, curr_info.pass_index, curr_info.constant_index, state.curr_lerp );
                }
            }

            break;
        case 2:
            if ( state.force_update || state.prev_slot != state.curr_slot || state.prev_lerp <= state.curr_lerp )
                setblurbylocalclientnum( localclientnum, curr_info.magnitude, curr_info.transition_in );

            break;
        case 3:
            if ( state.force_update || state.prev_slot != state.curr_slot || state.prev_lerp <= state.curr_lerp )
                setelectrified( localclientnum, curr_info.duration * state.curr_lerp );

            break;
        case 4:
            if ( state.force_update || state.prev_slot != state.curr_slot || state.prev_lerp <= state.curr_lerp )
                setburn( localclientnum, curr_info.duration * state.curr_lerp );

            break;
        case 5:
            if ( state.force_update || state.prev_slot != state.curr_slot || state.prev_lerp != state.curr_lerp )
                set_poison_overlay( state.curr_lerp );

            break;
    }
}
