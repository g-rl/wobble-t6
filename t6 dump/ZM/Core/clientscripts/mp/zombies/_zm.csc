// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_music;
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zombies\_zm_ffotd;
#include clientscripts\mp\zombies\_callbacks;
#include clientscripts\mp\zombies\_load;
#include clientscripts\mp\_visionset_mgr;
#include clientscripts\mp\zombies\_zm_audio;
#include clientscripts\mp\_audio;
#include clientscripts\mp\zombies\_zm_clone;
#include clientscripts\mp\zombies\_zm_buildables;
#include clientscripts\mp\zombies\_zm_magicbox;
#include clientscripts\mp\zombies\_zm_perks;
#include clientscripts\mp\zombies\_zm_powerups;
#include clientscripts\mp\zombies\_zm_score;
#include clientscripts\mp\zombies\_zm_traps;
#include clientscripts\mp\zombies\_zm_gump;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_equipment;
#include clientscripts\mp\_sticky_grenade;

init()
{
/#
    println( "ZM >> Zombiemode Client Scripts Init (_zm.csc) " );
#/
    level thread clientscripts\mp\zombies\_zm_ffotd::main_start();
    level.onlinegame = sessionmodeisonlinegame();
    level.swimmingfeature = 0;
    level.scr_zm_ui_gametype = getdvar( #"ui_gametype" );
    level.scr_zm_map_start_location = getdvar( #"ui_zm_mapstartlocation" );
    level.gamedifficulty = getgametypesetting( "zmDifficulty" );
    level.enable_magic = getgametypesetting( "magic" );
    level.headshots_only = getgametypesetting( "headshotsonly" );
    level.on_finalize_initialization_callback = clientscripts\mp\zombies\_callbacks::onfinalizeinitialization_callback;
    clientscripts\mp\zombies\_load::main();
    clientscripts\mp\_visionset_mgr::init();
    clientscripts\mp\_utility::registersystem( "lsm", ::last_stand_monitor );
    level.clientvoicesetup = clientscripts\mp\zombies\_zm_audio::clientvoicesetup;
    level.playerfalldamagesound = clientscripts\mp\zombies\_zm_audio::playerfalldamagesound;
    thread clientscripts\mp\_audio::audio_init( 0 );
    clientscripts\mp\zombies\_zm_audio::init();
/#
    println( "ZM >> init_client_flags (_zm.csc) " );
#/
    init_client_flags();
/#
    println( "ZM >> init_client_flag_callback_funcs (_zm.csc) " );
#/
    init_client_flag_callback_funcs();
    registerclientfield( "actor", "zombie_has_eyes", 1, 1, "int", ::zombie_eyes_clientfield_cb, 0 );
    registerclientfield( "actor", "zombie_ragdoll_explode", 1, 1, "int", ::zombie_ragdoll_explode_cb, 0 );
    registerclientfield( "actor", "zombie_gut_explosion", 9000, 1, "int", ::zombie_gut_explosion_cb, 0 );
    registerclientfield( "world", "zombie_power_on", 1, 1, "int", ::zombie_power_clientfield_cb, 1 );
    registerclientfield( "actor", "sndZombieContext", 9000, 1, "int", clientscripts\mp\zombies\_zm_audio::sndsetzombiecontext );
    registerclientfield( "actor", "sndZombieContext", -12000, 1, "int", clientscripts\mp\zombies\_zm_audio::sndsetzombiecontext );
    clientscripts\mp\zombies\_zm_clone::init();
    clientscripts\mp\zombies\_zm_buildables::init();
    clientscripts\mp\zombies\_zm_magicbox::init();
    clientscripts\mp\zombies\_zm_perks::init();
    clientscripts\mp\zombies\_zm_powerups::init();
    clientscripts\mp\zombies\_zm_score::init();
    clientscripts\mp\zombies\_zm_traps::init();
    clientscripts\mp\zombies\_zm_gump::init();
    clientscripts\mp\zombies\_zm_weapons::init();
    clientscripts\mp\zombies\_zm_equipment::init();
    init_blocker_fx();
    init_riser_fx();
    init_wallbuy_fx();
    init_zombie_explode_fx();
    level._playerspawned_override = ::playerspawned;
    level._entityspawned_override = ::entityspawned;
    level.gibresettime = 0.5;
    level.gibmaxcount = 3;
    level.gibtimer = 0;
    level.gibcount = 0;
    level._gibeventcbfunc = ::on_gib_event;
    level thread resetgibcounter();
    level thread zpo_listener();
    level thread zpoff_listener();
    level._box_indicator_no_lights = -1;
    level._box_indicator_flash_lights_moving = 99;
    level._box_indicator_flash_lights_fire_sale = 98;
    level._box_indicator = level._box_indicator_no_lights;
    registersystem( "box_indicator", ::box_monitor );
    level._zombie_gib_piece_index_all = 0;
    level._zombie_gib_piece_index_right_arm = 1;
    level._zombie_gib_piece_index_left_arm = 2;
    level._zombie_gib_piece_index_right_leg = 3;
    level._zombie_gib_piece_index_left_leg = 4;
    level._zombie_gib_piece_index_head = 5;
    level._zombie_gib_piece_index_guts = 6;
    level._zombie_gib_piece_index_hat = 7;
    level._customplayerconnectfuncs = ::drive_client_connected_notifies;
    onplayerconnect_callback( ::basic_player_connect );
    level.callbackprecachegametype = ::precache_zombie_gametype;
    level.callbackstartgametype = ::start_zombie_gametype;
    level thread clientscripts\mp\zombies\_zm_ffotd::main_end();
}

zombe_gametype_premain()
{
    gamemode = getdvar( #"ui_gametype" );

    if ( !isdefined( level.gamemode_map_location_main ) || !isdefined( level.gamemode_map_location_main[gamemode] ) )
        return;

    if ( getdvar( #"createfx" ) != "" )
        return;

    if ( isdefined( level._zombie_gamemodepremain ) )
        level thread [[ level._zombie_gamemodepremain ]]();

    if ( isdefined( level.gamemode_map_location_main[gamemode] ) )
    {
        loc = getdvar( #"ui_zm_mapstartlocation" );

        if ( loc == "" && isdefined( level.default_start_location ) )
            loc = level.default_start_location;

        if ( isdefined( level.gamemode_map_location_premain[gamemode][loc] ) )
            level thread [[ level.gamemode_map_location_premain[gamemode][loc] ]]();
    }
}

start_zombie_gametype()
{
    gamemode = getdvar( #"ui_gametype" );

    if ( !isdefined( level.gamemode_map_location_main ) || !isdefined( level.gamemode_map_location_main[gamemode] ) )
        return;

    if ( getdvar( #"createfx" ) != "" )
        return;

    if ( isdefined( level.gamemode_map_main ) )
    {
        if ( isdefined( level.gamemode_map_main[gamemode] ) )
            level thread delay_for_clients_then_execute( level.gamemode_map_main[gamemode] );
    }

    if ( isdefined( level.gamemode_map_location_main ) )
    {
        if ( isdefined( level.gamemode_map_location_main[gamemode] ) )
        {
            loc = getdvar( #"ui_zm_mapstartlocation" );

            if ( loc == "" && isdefined( level.default_start_location ) )
                loc = level.default_start_location;

            if ( isdefined( level.gamemode_map_location_main[gamemode][loc] ) )
                level thread delay_for_clients_then_execute( level.gamemode_map_location_main[gamemode][loc] );
        }
    }

    if ( isdefined( level._zombie_gamemodemain ) )
        level thread delay_for_clients_then_execute( level._zombie_gamemodemain );
}

delay_for_clients_then_execute( func )
{
    wait 0.1;
    players = getlocalplayers();

    for ( x = 0; x < players.size; x++ )
    {
        while ( !clienthassnapshot( x ) )
            wait 0.05;
    }

    wait 0.1;
    level thread [[ func ]]();
}

precache_zombie_gametype()
{
    gamemode = getdvar( #"ui_gametype" );

    if ( !isdefined( level.gamemode_map_location_main ) || !isdefined( level.gamemode_map_location_main[gamemode] ) )
        return;

    if ( isdefined( level._zombie_gamemodeprecache ) )
        [[ level._zombie_gamemodeprecache ]]();

    if ( isdefined( level.gamemode_map_precache ) )
    {
        if ( isdefined( level.gamemode_map_precache[gamemode] ) )
            [[ level.gamemode_map_precache[gamemode] ]]();
    }

    if ( isdefined( level.gamemode_map_location_precache ) )
    {
        if ( isdefined( level.gamemode_map_location_precache[gamemode] ) )
        {
            loc = getdvar( #"ui_zm_mapstartlocation" );

            if ( loc == "" && isdefined( level.default_start_location ) )
                loc = level.default_start_location;

            if ( isdefined( level.gamemode_map_location_precache[gamemode][loc] ) )
                [[ level.gamemode_map_location_precache[gamemode][loc] ]]();
        }
    }
}

add_map_gamemode( mode, precache_func, main_func )
{
    if ( !isdefined( level.gamemode_map_location_init ) )
        level.gamemode_map_location_init = [];

    if ( !isdefined( level.gamemode_map_location_main ) )
        level.gamemode_map_location_main = [];

    if ( !isdefined( level.gamemode_map_precache ) )
        level.gamemode_map_precache = [];

    if ( !isdefined( level.gamemode_map_main ) )
        level.gamemode_map_main = [];

    level.gamemode_map_main[mode] = main_func;
    level.gamemode_map_precache[mode] = precache_func;
    level.gamemode_map_location_precache[mode] = [];
    level.gamemode_map_location_premain_func[mode] = [];
    level.gamemode_map_location_main[mode] = [];
}

add_map_location_gamemode( mode, location, precache_func, premain_func, main_func )
{
    if ( !isdefined( level.gamemode_map_location_precache[mode] ) )
    {
/#
        println( "*** ERROR : " + mode + " has not been added to the map using add_map_gamemode." );
#/
        return;
    }

    level.gamemode_map_location_precache[mode][location] = precache_func;
    level.gamemode_map_location_premain[mode][location] = premain_func;
    level.gamemode_map_location_main[mode][location] = main_func;
}

drive_client_connected_notifies( player, localclientnum )
{
    player callback( "on_player_connect", localclientnum );
}

basic_player_connect( localclientnum )
{
    if ( !isdefined( level._laststand ) )
        level._laststand = [];

    level._laststand[localclientnum] = 0;
    self thread force_update_player_clientfields( localclientnum );
}

force_update_player_clientfields( localclientnum )
{
    self endon( "entityshutdown" );

    while ( !clienthassnapshot( localclientnum ) )
        wait 0.25;

    wait 0.25;
    self processclientfieldsasifnew();
}

playerspawned( localclientnum )
{
    self endon( "entityshutdown" );
/#
    println( "Player spawned" );
#/
    level.localplayers = getlocalplayers();

    if ( isdefined( level._faceanimcbfunc ) )
        self thread [[ level._faceanimcbfunc ]]( localclientnum );
}

entityspawned( localclientnum )
{
    if ( !isdefined( self.type ) )
    {
/#
        println( "Entity type undefined!" );
#/
        return;
    }

    if ( self.type == "player" )
        self thread playerspawned( localclientnum );

    if ( self.type == "missile" )
    {
        switch ( self.weapon )
        {
            case "sticky_grenade_zm":
                self thread clientscripts\mp\_sticky_grenade::spawned( localclientnum );
                break;
        }
    }
}

init_wallbuy_fx()
{
    if ( !is_false( level._uses_default_wallbuy_fx ) )
    {
        level._effect["870mcs_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_870mcs" );
        level._effect["ak74u_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_ak74u" );
        level._effect["beretta93r_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_berreta93r" );
        level._effect["bowie_knife_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_bowie" );
        level._effect["claymore_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_claymore" );
        level._effect["m14_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_m14" );
        level._effect["m16_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_m16" );
        level._effect["mp5k_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_mp5k" );
        level._effect["rottweil72_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_olympia" );
    }

    if ( !is_false( level._uses_sticky_grenades ) )
    {
        if ( !is_true( level.disable_fx_zmb_wall_buy_semtex ) )
            level._effect["sticky_grenade_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_semtex" );
    }

    if ( !is_false( level._uses_taser_knuckles ) )
        level._effect["tazer_knuckles_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_taseknuck" );

    if ( isdefined( level.buildable_wallbuy_weapons ) )
        level._effect["dynamic_wallbuy_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_question" );
}

init_blocker_fx()
{
    level._effect["wood_chunk_destory"] = loadfx( "impacts/fx_large_woodhit" );
}

init_riser_fx()
{
    if ( isdefined( level.use_new_riser_water ) && level.use_new_riser_water )
    {
        level._effect["rise_burst_water"] = loadfx( "maps/zombie/fx_mp_zombie_hand_water_burst" );
        level._effect["rise_billow_water"] = loadfx( "maps/zombie/fx_mp_zombie_body_water_billowing" );
        level._effect["rise_dust_water"] = loadfx( "maps/zombie/fx_zombie_body_wtr_falling" );
    }

    level._effect["rise_burst"] = loadfx( "maps/zombie/fx_mp_zombie_hand_dirt_burst" );
    level._effect["rise_billow"] = loadfx( "maps/zombie/fx_mp_zombie_body_dirt_billowing" );
    level._effect["rise_dust"] = loadfx( "maps/zombie/fx_mp_zombie_body_dust_falling" );

    if ( isdefined( level.riser_type ) && level.riser_type == "snow" )
    {
        level._effect["rise_burst_snow"] = loadfx( "maps/zombie/fx_mp_zombie_hand_snow_burst" );
        level._effect["rise_billow_snow"] = loadfx( "maps/zombie/fx_mp_zombie_body_snow_billowing" );
        level._effect["rise_dust_snow"] = loadfx( "maps/zombie/fx_mp_zombie_body_snow_falling" );
    }
}

init_client_flags()
{
/#
    println( "ZM >> init_client_flags START(_zm.csc) " );
#/
    level._zombie_scriptmover_flag_box_random = 15;

    if ( isdefined( level.use_clientside_board_fx ) && level.use_clientside_board_fx )
    {
        level._zombie_scriptmover_flag_board_horizontal_fx = 14;
        level._zombie_scriptmover_flag_board_vertical_fx = 13;
    }

    if ( isdefined( level.use_clientside_rock_tearin_fx ) && level.use_clientside_rock_tearin_fx )
        level._zombie_scriptmover_flag_rock_fx = 12;
}

init_client_flag_callback_funcs()
{
    level._client_flag_callbacks = [];
    level._client_flag_callbacks["vehicle"] = [];
    level._client_flag_callbacks["player"] = [];
    level._client_flag_callbacks["actor"] = [];
    level._client_flag_callbacks["scriptmover"] = [];
/#
    println( "ZM >> init_client_flag_callback_funcs START (_zm.csc) " );
#/

    if ( isdefined( level.use_clientside_board_fx ) && level.use_clientside_board_fx )
    {
        register_clientflag_callback( "scriptmover", level._zombie_scriptmover_flag_board_vertical_fx, ::handle_vertical_board_clientside_fx );
        register_clientflag_callback( "scriptmover", level._zombie_scriptmover_flag_board_horizontal_fx, ::handle_horizontal_board_clientside_fx );
    }

    if ( isdefined( level.use_clientside_rock_tearin_fx ) && level.use_clientside_rock_tearin_fx )
        register_clientflag_callback( "scriptmover", level._zombie_scriptmover_flag_rock_fx, ::handle_rock_clientside_fx );

/#
    println( "ZM >> register_clientflag_callback (_ZOMBIE_SCRIPTMOVER_FLAG_BOX_RANDOM) weapon_box_callback - client scripts" );
#/
    register_clientflag_callback( "scriptmover", level._zombie_scriptmover_flag_box_random, clientscripts\mp\zombies\_zm_weapons::weapon_box_callback );

    if ( !is_true( level.disable_deadshot_clientfield ) )
        registerclientfield( "toplayer", "deadshot_perk", 1, 1, "int", ::player_deadshot_perk_handler, 0, 1 );

    if ( !is_true( level._no_navcards ) )
    {
        if ( level.scr_zm_ui_gametype == "zclassic" && !level.createfx_enabled )
        {
            registerclientfield( "allplayers", "navcard_held", 1, 4, "int", undefined, 0, 1 );
            level thread set_clientfield_navcard_code_callback( "navcard_held" );
        }
    }

    if ( !is_true( level._no_water_risers ) )
        registerclientfield( "actor", "zombie_riser_fx_water", 1, 1, "int", ::handle_zombie_risers_water, 1 );

    if ( is_true( level._foliage_risers ) )
        registerclientfield( "actor", "zombie_riser_fx_foliage", 12000, 1, "int", ::handle_zombie_risers_foliage, 1 );

    registerclientfield( "actor", "zombie_riser_fx", 1, 1, "int", ::handle_zombie_risers, 1 );

    if ( is_true( level.risers_use_low_gravity_fx ) )
        registerclientfield( "actor", "zombie_riser_fx_lowg", 1, 1, "int", ::handle_zombie_risers_lowg, 1 );
}

handle_horizontal_board_clientside_fx( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( set )
    {
        localplayers = level.localplayers;
        snd_played = 0;

        for ( i = 0; i < localplayers.size; i++ )
        {
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 0, 0, 1 ), 30.0 ) );
            wait( randomfloatrange( 0.3, 0.6 ) );

            if ( !snd_played )
            {
                self thread do_teardown_sound( "plank" );
                snd_played = 1;
            }

            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 0, 0, -1 ), 30.0 ) );
        }
    }
    else
    {
        playsound( 0, "zmb_repair_boards", self.origin );
        localplayers = level.localplayers;
        snd_played = 0;
        wait 0.3;
        playsound( 0, "zmb_board_slam", self.origin );

        for ( i = 0; i < localplayers.size; i++ )
        {
            localplayers[i] earthquake( randomfloatrange( 0.3, 0.4 ), randomfloatrange( 0.2, 0.4 ), self.origin, 150 );
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 0, 0, 1 ), 30.0 ) );
            wait( randomfloatrange( 0.3, 0.6 ) );
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 0, 0, -1 ), 30.0 ) );
        }
    }
}

handle_vertical_board_clientside_fx( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( set )
    {
        localplayers = level.localplayers;
        snd_played = 0;

        for ( i = 0; i < localplayers.size; i++ )
        {
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 1, 0, 0 ), 30.0 ) );
            wait( randomfloatrange( 0.3, 0.6 ) );

            if ( !snd_played )
            {
                self thread do_teardown_sound( "plank" );
                snd_played = 1;
            }

            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( -1, 0, 0 ), 30.0 ) );
        }
    }
    else
    {
        localplayers = level.localplayers;
        snd_played = 0;
        playsound( 0, "zmb_repair_boards", self.origin );
        wait 0.3;
        playsound( 0, "zmb_board_slam", self.origin );

        for ( i = 0; i < localplayers.size; i++ )
        {
            localplayers[i] earthquake( randomfloatrange( 0.3, 0.4 ), randomfloatrange( 0.2, 0.4 ), self.origin, 150 );
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 1, 0, 0 ), 30.0 ) );
            wait( randomfloatrange( 0.3, 0.6 ) );
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( -1, 0, 0 ), 30.0 ) );
        }
    }
}

handle_rock_clientside_fx( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( set )
    {
        localplayers = level.localplayers;
        snd_played = 0;

        for ( i = 0; i < localplayers.size; i++ )
        {
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 1, 0, 0 ), 30.0 ) );
            wait( randomfloatrange( 0.3, 0.6 ) );

            if ( !snd_played )
            {
                self thread do_teardown_sound( "rock" );
                snd_played = 1;
            }

            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( -1, 0, 0 ), 30.0 ) );
        }
    }
    else
    {
        localplayers = level.localplayers;
        snd_played = 0;
        playsound( 0, "zmb_repair_boards", self.origin );
        playsound( 0, "zmb_cha_ching", self.origin );

        for ( i = 0; i < localplayers.size; i++ )
        {
            localplayers[i] earthquake( randomfloatrange( 0.3, 0.4 ), randomfloatrange( 0.2, 0.4 ), self.origin, 150 );
            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( 1, 0, 0 ), 30.0 ) );
            wait( randomfloatrange( 0.3, 0.6 ) );

            if ( !snd_played )
            {
                playsound( 0, "zmb_break_rock_barrier_fix", self.origin );
                snd_played = 1;
            }

            playfx( i, level._effect["wood_chunk_destory"], self.origin + vectorscale( ( -1, 0, 0 ), 30.0 ) );
        }
    }
}

do_teardown_sound( type )
{
    switch ( type )
    {
        case "rock":
            playsound( 0, "zmb_break_rock_barrier_fix", self.origin );
            wait( randomfloatrange( 0.3, 0.6 ) );
            playsound( 0, "zmb_break_rock_barrier_fix", self.origin );
            break;
        case "plank":
            playsound( 0, "zmb_break_boards", self.origin );
            wait( randomfloatrange( 0.3, 0.6 ) );
            playsound( 0, "zmb_break_boards", self.origin );
            break;
    }
}

box_monitor( clientnum, state, oldstate )
{
    if ( isdefined( level._custom_box_monitor ) )
        [[ level._custom_box_monitor ]]( clientnum, state, oldstate );
}

zpo_listener()
{
    while ( true )
    {
        level waittill( "ZPO" );
        level notify( "power_on" );
        level notify( "revive_on" );
        level notify( "middle_door_open" );
        level notify( "fast_reload_on" );
        level notify( "doubletap_on" );
        level notify( "divetonuke_on" );
        level notify( "marathon_on" );
        level notify( "jugger_on" );
        level notify( "additionalprimaryweapon_on" );
    }
}

zpoff_listener()
{
    while ( true )
        level waittill( "ZPOff" );
}

zombie_power_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        level notify( "ZPO" );
    else if ( oldval == 1 )
        level notify( "ZPOff" );
}

player_deadshot_perk_handler( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !self islocalplayer() || isspectating( localclientnum, 0 ) || isdefined( level.localplayers[localclientnum] ) && self getentitynumber() != level.localplayers[localclientnum] getentitynumber() )
        return;

    if ( newval )
        self usealternateaimparams();
    else
        self clearalternateaimparams();
}

createzombieeyesinternal( localclientnum )
{
    self endon( "entityshutdown" );
    self waittill_dobj( localclientnum );

    if ( !isdefined( self._eyearray ) )
        self._eyearray = [];

    if ( !isdefined( self._eyearray[localclientnum] ) )
    {
        linktag = "J_Eyeball_LE";
        effect = level._effect["eye_glow"];

        if ( isdefined( level._override_eye_fx ) )
            effect = level._override_eye_fx;

        if ( isdefined( self._eyeglow_fx_override ) )
            effect = self._eyeglow_fx_override;

        if ( isdefined( self._eyeglow_tag_override ) )
            linktag = self._eyeglow_tag_override;

        self._eyearray[localclientnum] = playfxontag( localclientnum, effect, self, linktag );
    }
}

createzombieeyes( localclientnum )
{
    self thread createzombieeyesinternal( localclientnum );
}

deletezombieeyes( localclientnum )
{
    if ( isdefined( self._eyearray ) )
    {
        if ( isdefined( self._eyearray[localclientnum] ) )
        {
            deletefx( localclientnum, self._eyearray[localclientnum], 1 );
            self._eyearray[localclientnum] = undefined;
        }
    }
}

player_eyes_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( self isplayer() )
    {
        self.zombie_face = newval;
        self notify( "face", "face_advance" );

        if ( is_true( self.special_eyes ) )
            self._eyeglow_fx_override = level._effect["player_eye_glow_blue"];
        else
            self._eyeglow_fx_override = level._effect["player_eye_glow_orng"];
    }

    if ( self isplayer() && self islocalplayer() && !isdemoplaying() )
    {
        if ( localclientnum == self getlocalclientnumber() )
            return;
    }

    if ( !isdemoplaying() )
        zombie_eyes_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump );
    else
        zombie_eyes_demo_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump );
}

player_eye_color_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( self isplayer() && self islocalplayer() && !isdemoplaying() )
    {
        if ( localclientnum == self getlocalclientnumber() )
            return;
    }

    if ( !isdefined( self.special_eyes ) || self.special_eyes != newval )
    {
        self.special_eyes = newval;

        if ( is_true( self.special_eyes ) )
            self._eyeglow_fx_override = level._effect["player_eye_glow_blue"];
        else
            self._eyeglow_fx_override = level._effect["player_eye_glow_orng"];

        if ( !isdemoplaying() )
            zombie_eyes_clientfield_cb( localclientnum, 0, is_true( self.zombie_face ), bnewent, binitialsnap, fieldname, bwasdemojump );
        else
            zombie_eyes_demo_clientfield_cb( localclientnum, 0, is_true( self.zombie_face ), bnewent, binitialsnap, fieldname, bwasdemojump );
    }
}

zombie_eyes_handle_demo_jump( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "death_or_disconnect" );
    self endon( "new_zombie_eye_cb" );

    while ( true )
    {
        level waittill_any( "demo_jump", "demo_player_switch" );
        self deletezombieeyes( localclientnum );
        self mapshaderconstant( localclientnum, 0, "scriptVector2", 0, 0.25, self get_eyeball_color() );
        self.eyes_spawned = 0;
    }
}

zombie_eyes_demo_watcher( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "entityshutdown" );
    self endon( "death_or_disconnect" );
    self endon( "new_zombie_eye_cb" );
    self thread zombie_eyes_handle_demo_jump( localclientnum );

    if ( newval )
    {
        while ( true )
        {
            if ( !self islocalplayer() || isspectating( localclientnum, 1 ) || localclientnum != self getlocalclientnumber() )
            {
                if ( !is_true( self.eyes_spawned ) )
                {
                    self createzombieeyes( localclientnum );
                    self mapshaderconstant( localclientnum, 0, "scriptVector2", 0, get_eyeball_luminance(), self get_eyeball_color() );
                    self.eyes_spawned = 1;
                }
            }
            else if ( is_true( self.eyes_spawned ) )
            {
                self deletezombieeyes( localclientnum );
                self mapshaderconstant( localclientnum, 0, "scriptVector2", 0, 0.25, self get_eyeball_color() );
                self.eyes_spawned = 0;
            }

            wait 0.016;
        }
    }
    else
    {
        self deletezombieeyes( localclientnum );
        self mapshaderconstant( localclientnum, 0, "scriptVector2", 0, 0.25, self get_eyeball_color() );
        self.eyes_spawned = 0;
    }
}

zombie_eyes_demo_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self notify( "new_zombie_eye_cb" );
    self thread zombie_eyes_demo_watcher( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump );
}

zombie_eyes_clientfield_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isdefined( newval ) )
        return;

    if ( newval )
    {
        self createzombieeyes( localclientnum );
        self mapshaderconstant( localclientnum, 0, "scriptVector2", 0, get_eyeball_luminance(), self get_eyeball_color() );
    }
    else
    {
        self deletezombieeyes( localclientnum );
        self mapshaderconstant( localclientnum, 0, "scriptVector2", 0, 0.25, self get_eyeball_color() );
    }

    if ( isdefined( level.zombie_eyes_clientfield_cb_additional ) )
        self [[ level.zombie_eyes_clientfield_cb_additional ]]( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump );
}

get_eyeball_luminance()
{
    if ( isdefined( level.eyeball_luminance_override ) )
        return level.eyeball_luminance_override;

    return 2;
}

get_eyeball_color()
{
    val = 0;

    if ( isdefined( level.zombie_eyeball_color_override ) )
        val = level.zombie_eyeball_color_override;

    if ( isdefined( self.zombie_eyeball_color_override ) )
        val = self.zombie_eyeball_color_override;

    return val;
}

zombie_ragdoll_explode_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        self zombie_wait_explode( localclientnum );
}

zombie_gut_explosion_cb( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
    {
        if ( isdefined( level._effect["zombie_guts_explosion"] ) )
        {
            org = self gettagorigin( "J_SpineLower" );

            if ( isdefined( org ) )
                playfx( localclientnum, level._effect["zombie_guts_explosion"], org );
        }
    }
}

init_zombie_explode_fx()
{
    level._effect["zombie_guts_explosion"] = loadfx( "maps/zombie/fx_zmb_tranzit_torso_explo" );
}

zombie_wait_explode( localclientnum )
{
    where = self gettagorigin( "J_SpineLower" );

    if ( !isdefined( where ) )
        where = self.origin;

    start = gettime();

    while ( gettime() - start < 2000 )
    {
        if ( isdefined( self ) )
        {
            where = self gettagorigin( "J_SpineLower" );

            if ( !isdefined( where ) )
                where = self.origin;
        }

        wait 0.05;
    }

    if ( isdefined( level._effect["zombie_guts_explosion"] ) && is_mature() )
        playfx( localclientnum, level._effect["zombie_guts_explosion"], where );
}

init_perk_machines_fx()
{
    if ( !level.enable_magic )
        return;

    wait 0.1;
    vending_triggers = getentarray( 0, "zombie_vending", "targetname" );

    if ( vending_triggers.size < 1 )
        return;

    level._effect["sleight_light"] = loadfx( "misc/fx_zombie_cola_on" );
    level._effect["doubletap_light"] = loadfx( "misc/fx_zombie_cola_dtap_on" );
    level._effect["divetonuke_light"] = loadfx( "misc/fx_zombie_cola_dtap_on" );
    level._effect["marathon_light"] = loadfx( "misc/fx_zombie_cola_dtap_on" );
    level._effect["jugger_light"] = loadfx( "misc/fx_zombie_cola_jugg_on" );
    level._effect["revive_light"] = loadfx( "misc/fx_zombie_cola_revive_on" );
    level._effect["additionalprimaryweapon_light"] = loadfx( "misc/fx_zombie_cola_dtap_on" );
    level thread perk_start_up();
}

perk_start_up()
{
    level waittill( "power_on" );
    timer = 0;
    duration = 0.1;
    machines = getstructarray( "perksacola", "targetname" );

    while ( true )
    {
        for ( i = 0; i < machines.size; i++ )
        {
            switch ( machines[i].script_sound )
            {
                case "mx_jugger_jingle":
                    machines[i] thread vending_machine_flicker_light( "jugger_light", duration );
                    break;
                case "mx_speed_jingle":
                    machines[i] thread vending_machine_flicker_light( "sleight_light", duration );
                    break;
                case "mx_doubletap_jingle":
                    machines[i] thread vending_machine_flicker_light( "doubletap_light", duration );
                    break;
                case "mx_divetonuke_jingle":
                    machines[i] thread vending_machine_flicker_light( "divetonuke_light", duration );
                    break;
                case "mx_marathon_jingle":
                    machines[i] thread vending_machine_flicker_light( "marathon_light", duration );
                    break;
                case "mx_revive_jingle":
                    machines[i] thread vending_machine_flicker_light( "revive_light", duration );
                    break;
                case "mx_additionalprimaryweapon_jingle":
                    machines[i] thread vending_machine_flicker_light( "additionalprimaryweapon_light", duration );
                    break;
                default:
                    machines[i] thread vending_machine_flicker_light( "jugger_light", duration );
                    break;
            }
        }

        timer = timer + duration;
        duration = duration + 0.2;

        if ( timer >= 3 )
            break;

        waitrealtime( duration );
    }
}

vending_machine_flicker_light( fx_light, duration )
{
    players = level.localplayers;

    for ( i = 0; i < players.size; i++ )
        self thread play_perk_fx_on_client( i, fx_light, duration );
}

play_perk_fx_on_client( client_num, fx_light, duration )
{
    fxobj = spawn( client_num, self.origin + vectorscale( ( 0, 0, -1 ), 50.0 ), "script_model" );
    fxobj setmodel( "tag_origin" );
    playfxontag( client_num, level._effect[fx_light], fxobj, "tag_origin" );
    waitrealtime( duration );
    fxobj delete();
}

mark_piece_gibbed( piece_index )
{
    if ( !isdefined( self.gibbed_pieces ) )
        self.gibbed_pieces = [];

    self.gibbed_pieces[self.gibbed_pieces.size] = piece_index;
}

has_gibbed_piece( piece_index )
{
    if ( !isdefined( self.gibbed_pieces ) )
        return false;

    for ( i = 0; i < self.gibbed_pieces.size; i++ )
    {
        if ( self.gibbed_pieces[i] == piece_index )
            return true;
    }

    return false;
}

do_headshot_gib_fx()
{
    fxtag = "j_neck";
    fxorigin = self gettagorigin( fxtag );
    upvec = anglestoup( self gettagangles( fxtag ) );
    forwardvec = anglestoforward( self gettagangles( fxtag ) );
    players = level.localplayers;

    for ( i = 0; i < players.size; i++ )
    {
        playfx( i, level._effect["headshot"], fxorigin, forwardvec, upvec );
        playfx( i, level._effect["headshot_nochunks"], fxorigin, forwardvec, upvec );
    }

    playsound( 0, "zombie_head_gib", fxorigin );
    wait 0.3;

    if ( isdefined( self ) )
    {
        players = level.localplayers;

        for ( i = 0; i < players.size; i++ )
            playfxontag( i, level._effect["bloodspurt"], self, fxtag );
    }
}

do_gib_fx( tag )
{
    players = level.localplayers;

    for ( i = 0; i < players.size; i++ )
        playfxontag( i, level._effect["animscript_gib_fx"], self, tag );

    playsound( 0, "zmb_death_gibs", self gettagorigin( tag ) );
}

do_gib( model, tag )
{
    start_pos = self gettagorigin( tag );
    start_angles = self gettagangles( tag );
    wait 0.016;
    end_pos = undefined;
    angles = undefined;

    if ( !isdefined( self ) )
    {
        end_pos = start_pos + anglestoforward( start_angles ) * 10;
        angles = start_angles;
    }
    else
    {
        end_pos = self gettagorigin( tag );
        angles = self gettagangles( tag );
    }

    if ( isdefined( self._gib_vel ) )
    {
        forward = self._gib_vel;
        self._gib_vel = undefined;
    }
    else
    {
        forward = vectornormalize( end_pos - start_pos );
        forward = forward * randomfloatrange( 0.6, 1.0 );
        forward = forward + ( 0, 0, randomfloatrange( 0.4, 0.7 ) );
    }

    createdynentandlaunch( 0, model, end_pos, angles, start_pos, forward, level._effect["animscript_gibtrail_fx"], 1 );

    if ( isdefined( self ) )
        self do_gib_fx( tag );
    else
        playsound( 0, "zmb_death_gibs", end_pos );
}

do_hat_gib( model, tag )
{
    start_pos = self gettagorigin( tag );
    start_angles = self gettagangles( tag );
    up_angles = ( 0, 0, 1 );
    force = ( 0, 0, randomfloatrange( 1.4, 1.7 ) );
    createdynentandlaunch( 0, model, start_pos, up_angles, start_pos, force );
}

check_should_gib()
{
    if ( level.gibcount <= level.gibmaxcount )
        return true;

    return false;
}

resetgibcounter()
{
    self endon( "disconnect" );

    while ( true )
    {
        wait( level.gibresettime );
        level.gibtimer = 0;
        level.gibcount = 0;
    }
}

on_gib_event( localclientnum, type, locations )
{
    if ( localclientnum != 0 )
        return;

    if ( !is_mature() )
        return;

    if ( !isdefined( self._gib_def ) )
        return;

    if ( isdefined( level._gib_overload_func ) )
    {
        if ( self [[ level._gib_overload_func ]]( type, locations ) )
            return;
    }

    if ( !check_should_gib() )
        return;

    level.gibcount++;

    for ( i = 0; i < locations.size; i++ )
    {
        if ( isdefined( self.gibbed ) && level._zombie_gib_piece_index_head != locations[i] )
            continue;

        switch ( locations[i] )
        {
            case 0:
                if ( isdefined( self._gib_def.gibspawn1 ) && isdefined( self._gib_def.gibspawntag1 ) )
                    self thread do_gib( self._gib_def.gibspawn1, self._gib_def.gibspawntag1 );

                if ( isdefined( self._gib_def.gibspawn2 ) && isdefined( self._gib_def.gibspawntag2 ) )
                    self thread do_gib( self._gib_def.gibspawn2, self._gib_def.gibspawntag2 );

                if ( isdefined( self._gib_def.gibspawn3 ) && isdefined( self._gib_def.gibspawntag3 ) )
                    self thread do_gib( self._gib_def.gibspawn3, self._gib_def.gibspawntag3 );

                if ( isdefined( self._gib_def.gibspawn4 ) && isdefined( self._gib_def.gibspawntag4 ) )
                    self thread do_gib( self._gib_def.gibspawn4, self._gib_def.gibspawntag4 );

                if ( isdefined( self._gib_def.gibspawn5 ) && isdefined( self._gib_def.gibspawntag5 ) )
                    self thread do_hat_gib( self._gib_def.gibspawn5, self._gib_def.gibspawntag5 );

                self thread do_headshot_gib_fx();
                self thread do_gib_fx( "J_SpineLower" );
                mark_piece_gibbed( level._zombie_gib_piece_index_right_arm );
                mark_piece_gibbed( level._zombie_gib_piece_index_left_arm );
                mark_piece_gibbed( level._zombie_gib_piece_index_right_leg );
                mark_piece_gibbed( level._zombie_gib_piece_index_left_leg );
                mark_piece_gibbed( level._zombie_gib_piece_index_head );
                mark_piece_gibbed( level._zombie_gib_piece_index_hat );
                break;
            case 1:
                if ( isdefined( self._gib_def.gibspawn1 ) && isdefined( self._gib_def.gibspawntag1 ) )
                    self thread do_gib( self._gib_def.gibspawn1, self._gib_def.gibspawntag1 );
                else
                {
                    if ( !isdefined( self._gib_def.gibspawn1 ) )
                    {

                    }

                    if ( !isdefined( self._gib_def.gibspawntag1 ) )
                    {

                    }
                }

                mark_piece_gibbed( level._zombie_gib_piece_index_right_arm );
                break;
            case 2:
                if ( isdefined( self._gib_def.gibspawn2 ) && isdefined( self._gib_def.gibspawntag2 ) )
                    self thread do_gib( self._gib_def.gibspawn2, self._gib_def.gibspawntag2 );
                else
                {
                    if ( !isdefined( self._gib_def.gibspawn2 ) )
                    {

                    }

                    if ( !isdefined( self._gib_def.gibspawntag2 ) )
                    {

                    }
                }

                mark_piece_gibbed( level._zombie_gib_piece_index_left_arm );
                break;
            case 3:
                if ( isdefined( self._gib_def.gibspawn3 ) && isdefined( self._gib_def.gibspawntag3 ) )
                    self thread do_gib( self._gib_def.gibspawn3, self._gib_def.gibspawntag3 );

                mark_piece_gibbed( level._zombie_gib_piece_index_right_leg );
                break;
            case 4:
                if ( isdefined( self._gib_def.gibspawn4 ) && isdefined( self._gib_def.gibspawntag4 ) )
                    self thread do_gib( self._gib_def.gibspawn4, self._gib_def.gibspawntag4 );

                mark_piece_gibbed( level._zombie_gib_piece_index_left_leg );
                break;
            case 5:
                self thread do_headshot_gib_fx();
                mark_piece_gibbed( level._zombie_gib_piece_index_head );
                break;
            case 6:
                self thread do_gib_fx( "J_SpineLower" );
                break;
            case 7:
                if ( isdefined( self._gib_def.gibspawn5 ) && isdefined( self._gib_def.gibspawntag5 ) )
                    self thread do_hat_gib( self._gib_def.gibspawn5, self._gib_def.gibspawntag5 );

                mark_piece_gibbed( level._zombie_gib_piece_index_hat );
                break;
        }
    }

    self.gibbed = 1;
}

zombie_vision_set_apply( str_visionset, int_priority, flt_transition_time, int_clientnum )
{
    self endon( "death" );
    self endon( "disconnect" );

    if ( !isdefined( self._zombie_visionset_list ) )
        self._zombie_visionset_list = [];

    if ( !isdefined( str_visionset ) || !isdefined( int_priority ) )
        return;

    if ( !isdefined( flt_transition_time ) )
        flt_transition_time = 1;

    if ( !isdefined( int_clientnum ) )
    {
        if ( self islocalplayer() )
            int_clientnum = self getlocalclientnumber();

        if ( !isdefined( int_clientnum ) )
            return;
    }

    already_in_array = 0;

    if ( self._zombie_visionset_list.size != 0 )
    {
        for ( i = 0; i < self._zombie_visionset_list.size; i++ )
        {
            if ( isdefined( self._zombie_visionset_list[i].vision_set ) && self._zombie_visionset_list[i].vision_set == str_visionset )
            {
                already_in_array = 1;

                if ( self._zombie_visionset_list[i].priority != int_priority )
                    self._zombie_visionset_list[i].priority = int_priority;

                break;
            }
        }
    }

    if ( !already_in_array )
    {
        temp_struct = spawnstruct();
        temp_struct.vision_set = str_visionset;
        temp_struct.priority = int_priority;
        self._zombie_visionset_list = add_to_array( self._zombie_visionset_list, temp_struct, 0 );
    }

    vision_to_set = self zombie_highest_vision_set_apply();

    if ( isdefined( vision_to_set ) )
        visionsetnaked( int_clientnum, vision_to_set, flt_transition_time );
    else
        visionsetnaked( int_clientnum, "undefined", flt_transition_time );
}

zombie_vision_set_remove( str_visionset, flt_transition_time, int_clientnum )
{
    self endon( "death" );
    self endon( "disconnect" );

    if ( !isdefined( str_visionset ) )
        return;

    if ( !isdefined( flt_transition_time ) )
        flt_transition_time = 1;

    if ( !isdefined( self._zombie_visionset_list ) )
        self._zombie_visionset_list = [];

    if ( !isdefined( int_clientnum ) )
    {
        if ( self islocalplayer() )
            int_clientnum = self getlocalclientnumber();

        if ( !isdefined( int_clientnum ) )
            return;
    }

    temp_struct = undefined;

    for ( i = 0; i < self._zombie_visionset_list.size; i++ )
    {
        if ( isdefined( self._zombie_visionset_list[i].vision_set ) && self._zombie_visionset_list[i].vision_set == str_visionset )
            temp_struct = self._zombie_visionset_list[i];
    }

    if ( isdefined( temp_struct ) )
        arrayremovevalue( self._zombie_visionset_list, temp_struct );

    vision_to_set = self zombie_highest_vision_set_apply();

    if ( isdefined( vision_to_set ) )
        visionsetnaked( int_clientnum, vision_to_set, flt_transition_time );
    else
        visionsetnaked( int_clientnum, "undefined", flt_transition_time );
}

zombie_highest_vision_set_apply()
{
    if ( !isdefined( self._zombie_visionset_list ) )
        return;

    highest_score = 0;
    highest_score_vision = undefined;

    for ( i = 0; i < self._zombie_visionset_list.size; i++ )
    {
        if ( isdefined( self._zombie_visionset_list[i].priority ) && self._zombie_visionset_list[i].priority > highest_score )
        {
            highest_score = self._zombie_visionset_list[i].priority;
            highest_score_vision = self._zombie_visionset_list[i].vision_set;
        }
    }

    return highest_score_vision;
}

handle_zombie_risers_foliage( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    level endon( "demo_jump" );
    self endon( "entityshutdown" );

    if ( !oldval && newval )
    {
        localplayers = level.localplayers;
        playsound( 0, "zmb_zombie_spawn", self.origin );
        burst_fx = level._effect["rise_burst_foliage"];
        billow_fx = level._effect["rise_billow_foliage"];
        type = "foliage";

        for ( i = 0; i < localplayers.size; i++ )
            self thread rise_dust_fx( i, type, billow_fx, burst_fx );
    }
}

handle_zombie_risers_water( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    level endon( "demo_jump" );
    self endon( "entityshutdown" );

    if ( !oldval && newval )
    {
        localplayers = level.localplayers;
        playsound( 0, "zmb_zombie_spawn_water", self.origin );
        burst_fx = level._effect["rise_burst_water"];
        billow_fx = level._effect["rise_billow_water"];
        type = "water";

        for ( i = 0; i < localplayers.size; i++ )
            self thread rise_dust_fx( i, type, billow_fx, burst_fx );
    }
}

handle_zombie_risers( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    level endon( "demo_jump" );
    self endon( "entityshutdown" );

    if ( !oldval && newval )
    {
        localplayers = level.localplayers;
        sound = "zmb_zombie_spawn";
        burst_fx = level._effect["rise_burst"];
        billow_fx = level._effect["rise_billow"];
        type = "dirt";

        if ( isdefined( level.riser_type ) && level.riser_type == "snow" )
        {
            sound = "zmb_zombie_spawn_snow";
            burst_fx = level._effect["rise_burst_snow"];
            billow_fx = level._effect["rise_billow_snow"];
            type = "snow";
        }

        playsound( 0, sound, self.origin );

        for ( i = 0; i < localplayers.size; i++ )
            self thread rise_dust_fx( i, type, billow_fx, burst_fx );
    }
}

handle_zombie_risers_lowg( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    level endon( "demo_jump" );
    self endon( "entityshutdown" );

    if ( !oldval && newval )
    {
        localplayers = level.localplayers;
        sound = "zmb_zombie_spawn";
        burst_fx = level._effect["rise_burst_lg"];
        billow_fx = level._effect["rise_billow_lg"];
        type = "dirt";

        if ( isdefined( level.riser_type ) && level.riser_type == "snow" )
        {
            sound = "zmb_zombie_spawn_snow";
            burst_fx = level._effect["rise_burst_snow"];
            billow_fx = level._effect["rise_billow_snow"];
            type = "snow";
        }

        playsound( 0, sound, self.origin );

        for ( i = 0; i < localplayers.size; i++ )
            self thread rise_dust_fx( i, type, billow_fx, burst_fx );
    }
}

rise_dust_fx( clientnum, type, billow_fx, burst_fx )
{
    dust_tag = "J_SpineUpper";
    self endon( "entityshutdown" );
    level endon( "demo_jump" );

    if ( isdefined( level.zombie_custom_riser_fx_handler ) )
    {
        s_info = self [[ level.zombie_custom_riser_fx_handler ]]();

        if ( isdefined( s_info ) )
        {
            if ( isdefined( s_info.burst_fx ) )
                burst_fx = s_info.burst_fx;

            if ( isdefined( s_info.billow_fx ) )
                billow_fx = s_info.billow_fx;

            if ( isdefined( s_info.type ) )
                type = s_info.type;
        }
    }

    if ( isdefined( burst_fx ) )
        playfx( clientnum, burst_fx, self.origin + ( 0, 0, randomintrange( 5, 10 ) ) );

    wait 0.25;

    if ( isdefined( billow_fx ) )
        playfx( clientnum, billow_fx, self.origin + ( randomintrange( -10, 10 ), randomintrange( -10, 10 ), randomintrange( 5, 10 ) ) );

    wait 2;
    dust_time = 5.5;
    dust_interval = 0.3;
    player = level.localplayers[clientnum];
    effect = level._effect["rise_dust"];

    if ( type == "water" )
        effect = level._effect["rise_dust_water"];
    else if ( type == "snow" )
        effect = level._effect["rise_dust_snow"];
    else if ( type == "foliage" )
        effect = level._effect["rise_dust_foliage"];
    else if ( type == "none" )
        return;

    for ( t = 0; t < dust_time; t = t + dust_interval )
    {
        playfxontag( clientnum, effect, self, dust_tag );
        wait( dust_interval );
    }
}

end_last_stand( clientnum )
{
    self waittill( "lastStandEnd" );
/#
    println( "Last stand ending for client " + clientnum );
#/
    waitrealtime( 0.7 );
/#
    println( "Gasp." );
#/
    playsound( clientnum, "revive_gasp" );
}

last_stand_thread( clientnum )
{
    self thread end_last_stand( clientnum );
    self endon( "lastStandEnd" );
/#
    println( "*** Client : Last stand starts on client " + clientnum );
#/
    pause = 0.5;
    vol = 0.5;

    while ( true )
    {
        id = playsound( clientnum, "chr_heart_beat" );
        setsoundvolume( id, vol );
        waitrealtime( pause );

        if ( pause < 2.0 )
        {
            pause = pause * 1.05;

            if ( pause > 2.0 )
                pause = 2.0;
        }

        if ( vol < 1.0 )
        {
            vol = vol * 1.05;

            if ( vol > 1.0 )
                vol = 1.0;
        }
    }
}

last_stand_monitor( clientnum, state, oldstate )
{
    player = level.localplayers[clientnum];
    players = level.localplayers;

    if ( !isdefined( player ) )
        return;

    if ( state == "1" )
    {
        if ( !level._laststand[clientnum] )
        {
            if ( !isdefined( level.lslooper ) )
                level.lslooper = spawn( 0, player.origin, "script.origin" );

            player thread last_stand_thread( clientnum );

            if ( players.size <= 1 )
                level.lslooper playloopsound( "evt_laststand_loop", 0.3 );

            level._laststand[clientnum] = 1;
        }
    }
    else if ( level._laststand[clientnum] )
    {
        if ( isdefined( level.lslooper ) )
        {
            level.lslooper stoploopsound( 0.7 );
            playsound( 0, "evt_laststand_in", ( 0, 0, 0 ) );
        }

        player notify( "lastStandEnd" );
        level._laststand[clientnum] = 0;
    }
}

set_clientfield_navcard_code_callback( cf_field_name )
{
    wait 0.1;
    setupclientfieldcodecallbacks( "allplayers", 1, cf_field_name );
}
