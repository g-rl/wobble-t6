// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_rewindobjects;
#include clientscripts\mp\_lights;

disableallparticlefxinlevel()
{

}

fx_validate( fxid, origin )
{
/#
    if ( level.createfx_enabled )
        return;

    if ( !isdefined( level._effect[fxid] ) )
    {
        assertmsg( "FX Not Precached: '" + fxid + "' at: " + origin );
    }
#/
}

createloopsound()
{
    ent = spawnstruct();

    if ( !isdefined( level.createfxent ) )
        level.createfxent = [];

    level.createfxent[level.createfxent.size] = ent;
    ent.v = [];
    ent.v["type"] = "soundfx";
    ent.v["fxid"] = "No FX";
    ent.v["soundalias"] = "nil";
    ent.v["angles"] = ( 0, 0, 0 );
    ent.v["origin"] = ( 0, 0, 0 );
    ent.drawn = 1;
    return ent;
}

createeffect( type, fxid )
{
    ent = spawnstruct();

    if ( !isdefined( level.createfxent ) )
        level.createfxent = [];

    level.createfxent[level.createfxent.size] = ent;
    ent.v = [];
    ent.v["type"] = type;
    ent.v["fxid"] = fxid;
    ent.v["angles"] = ( 0, 0, 0 );
    ent.v["origin"] = ( 0, 0, 0 );
    ent.drawn = 1;
    return ent;
}

createoneshoteffect( fxid )
{
    ent = createeffect( "oneshotfx", fxid );
    ent.v["delay"] = -15;
    return ent;
}

createloopeffect( fxid )
{
    ent = createeffect( "loopfx", fxid );
    ent.v["delay"] = 0.5;
    return ent;
}

createexploder( fxid )
{
    ent = createeffect( "exploder", fxid );
    ent.v["delay"] = 0;
    ent.v["exploder_type"] = "normal";
    return ent;
}

set_forward_and_up_vectors()
{
    self.v["up"] = anglestoup( self.v["angles"] );
    self.v["forward"] = anglestoforward( self.v["angles"] );
}

create_triggerfx( clientnum )
{
    fx_validate( self.v["fxid"], self.v["origin"] );
/#
    if ( getdvarint( #"debug_fx" ) > 0 )
        println( "self.v['fxid'] " + self.v["fxid"] );
#/

    if ( !level.createfx_disable_fx )
        self.looperfx = playfx( clientnum, level._effect[self.v["fxid"]], self.v["origin"], self.v["forward"], self.v["up"], self.v["delay"] );

    create_loopsound( clientnum );
}

create_looper( clientnum )
{
    self thread loopfx( clientnum );
    create_loopsound( clientnum );
}

loopfx( clientnum )
{
    if ( level.createfx_disable_fx )
        return;

    fx_validate( self.v["fxid"], self.v["origin"] );
    self.looperfx = playfx( clientnum, level._effect[self.v["fxid"]], self.v["origin"], self.v["forward"], self.v["up"], self.v["delay"] );

    while ( true )
    {
        if ( isdefined( self.v["delay"] ) )
        {
            if ( !serverwait( clientnum, self.v["delay"], 0.25 ) )
                continue;
        }

        while ( isfxplaying( clientnum, self.looperfx ) )
            wait 0.25;

        self.looperfx = playfx( clientnum, level._effect[self.v["fxid"]], self.v["origin"], self.v["forward"], self.v["up"] );
    }
}

loopfxstop( clientnum, timeout )
{
    self endon( "death" );
    wait( timeout );

    if ( isdefined( self.looper ) )
        deletefx( clientnum, self.looper );

    if ( isdefined( self.loopfx ) )
        deletefakeent( clientnum, self.loopfx );
}

loopfxthread( clientnum )
{
    if ( isdefined( self.fxstart ) )
        level waittill( "start fx" + self.fxstart );

    while ( true )
    {
        create_looper( clientnum );

        if ( isdefined( self.timeout ) )
            thread loopfxstop( clientnum, self.timeout );

        if ( isdefined( self.fxstop ) )
            level waittill( "stop fx" + self.fxstop );
        else
            return;

        if ( isdefined( self.looper ) )
            deletefx( clientnum, self.looper );

        if ( isdefined( self.fxstart ) )
            level waittill( "start fx" + self.fxstart );
        else
            return;
    }
}

playlightloopexploder( exploderindex )
{
    if ( level.createfx_enabled )
        return;

    if ( level.createfx_disable_fx )
        return;

    num = int( exploderindex );

    if ( isdefined( level.createfxexploders[num] ) )
    {
        for ( i = 0; i < level.createfxexploders[num].size; i++ )
        {
            ent = level.createfxexploders[num][i];

            if ( !isdefined( ent.looperfx ) )
                ent.looperfx = [];

            for ( clientnum = 0; clientnum < level.max_local_clients; clientnum++ )
            {
                if ( localclientactive( clientnum ) )
                {
                    if ( !isdefined( ent.looperfx[clientnum] ) )
                        ent.looperfx[clientnum] = [];

                    ent.looperfx[clientnum][ent.looperfx[clientnum].size] = ent playexploderfx( clientnum );
                }
            }
        }
    }
}

stoplightloopexploder( exploderindex )
{
    if ( level.createfx_enabled )
        return;

    num = int( exploderindex );

    if ( isdefined( level.createfxexploders[num] ) )
    {
        for ( i = 0; i < level.createfxexploders[num].size; i++ )
        {
            ent = level.createfxexploders[num][i];

            if ( !isdefined( ent.looperfx ) )
                ent.looperfx = [];

            for ( clientnum = 0; clientnum < level.max_local_clients; clientnum++ )
            {
                if ( localclientactive( clientnum ) )
                {
                    if ( isdefined( ent.looperfx[clientnum] ) )
                    {
                        for ( looperfxcount = 0; looperfxcount < ent.looperfx[clientnum].size; looperfxcount++ )
                            deletefx( clientnum, ent.looperfx[clientnum][looperfxcount] );
                    }
                }

                ent.looperfx[clientnum] = [];
            }

            ent.looperfx = [];
        }
    }
}

oneshotfxthread( clientnum )
{
    if ( self.v["delay"] > 0 )
        wait( self.v["delay"] );

    create_triggerfx( clientnum );
}

playexploderfx( clientnum )
{
/#
    if ( !isdefined( self.v["origin"] ) )
        return;

    if ( !isdefined( self.v["forward"] ) )
        return;

    if ( !isdefined( self.v["up"] ) )
        return;
#/

    if ( level.createfx_disable_fx )
        return;

    return playfx( clientnum, level._effect[self.v["fxid"]], self.v["origin"], self.v["forward"], self.v["up"] );
}

create_loopsound( clientnum )
{
    if ( clientnum != 0 )
        return;

    self notify( "stop_loop" );

    if ( isdefined( self.v["soundalias"] ) && self.v["soundalias"] != "nil" )
    {
        if ( isdefined( self.v["stopable"] ) && self.v["stopable"] )
            thread clientscripts\mp\_utility::loop_fx_sound( clientnum, self.v["soundalias"], self.v["origin"], "stop_loop" );
        else
            thread clientscripts\mp\_utility::loop_fx_sound( clientnum, self.v["soundalias"], self.v["origin"] );
    }
}

fx_init( clientnum )
{
    clientscripts\mp\_lights::init_lights( clientnum );

    if ( level.createfx_enabled )
    {
/#
        println( "*** ClientScripts : _CreateFX enabled.  Not creating client side effects." );
#/
        return;
    }

    if ( !isdefined( level.createfxent ) )
        return;

    creatingexploderarray = 0;

    if ( !isdefined( level.createfxexploders ) )
    {
        creatingexploderarray = 1;
        level.createfxexploders = [];
    }

    for ( i = 0; i < level.createfxent.size; i++ )
    {
        ent = level.createfxent[i];

        if ( !isdefined( level._createfxforwardandupset ) )
            ent set_forward_and_up_vectors();

        if ( ent.v["type"] == "loopfx" )
            ent thread loopfxthread( clientnum );

        if ( ent.v["type"] == "oneshotfx" )
            ent thread oneshotfxthread( clientnum );

        if ( ent.v["type"] == "soundfx" )
            ent thread create_loopsound( clientnum );

        if ( creatingexploderarray && ent.v["type"] == "exploder" )
        {
            if ( !isdefined( level.createfxexploders[ent.v["exploder"]] ) )
                level.createfxexploders[ent.v["exploder"]] = [];

            ent.v["exploder_id"] = getexploderid( ent );
            level.createfxexploders[ent.v["exploder"]][level.createfxexploders[ent.v["exploder"]].size] = ent;
        }
    }

    level._createfxforwardandupset = 1;
}

reportnumeffects()
{
/#
    if ( isdefined( level.createfxent ) )
        println( "*** ClientScripts : Added " + level.createfxent.size + " effects." );
    else
        println( "*** ClientScripts : Added no effects." );
#/
}

spawnfx_wrapper( clientnum, fx_id, origin, delay, forward, up )
{
    assert( isdefined( level._effect[fx_id] ), "Missing level._effect[\"" + fx_id + "\"]. You did not setup the fx before calling it in createFx." );
    fx_object = spawnfx( clientnum, level._effect[fx_id], origin, delay, forward, up );
    return fx_object;
}

blinky_light( localclientnum, tagname, friendlyfx, enemyfx )
{
    self endon( "entityshutdown" );
    self endon( "stop_blinky_light" );
    self.lighttagname = tagname;
    self waittill_dobj( localclientnum );
    self thread blinky_emp_wait( localclientnum );

    while ( true )
    {
        if ( isdefined( self.stunned ) && self.stunned )
        {
            wait 0.1;
            continue;
        }

        if ( isdefined( self ) )
        {
            if ( friendnotfoe( localclientnum ) )
                self.blinkylightfx = playfxontag( localclientnum, friendlyfx, self, self.lighttagname );
            else
                self.blinkylightfx = playfxontag( localclientnum, enemyfx, self, self.lighttagname );
        }

        serverwait( localclientnum, 0.5, 0.01 );
    }
}

stop_blinky_light( localclientnum )
{
    self notify( "stop_blinky_light" );

    if ( !isdefined( self.blinkylightfx ) )
        return;

    stopfx( localclientnum, self.blinkylightfx );
    self.blinkylightfx = undefined;
}

blinky_emp_wait( localclientnum )
{
    self endon( "entityshutdown" );
    self endon( "stop_blinky_light" );
    self waittill( "emp" );
    self stop_blinky_light( localclientnum );
}

activate_exploder( num )
{
    num = int( num );

    if ( isdefined( level.createfxexploders ) && isdefined( level.createfxexploders[num] ) )
    {
        for ( i = 0; i < level.createfxexploders[num].size; i++ )
            level.createfxexploders[num][i] activate_individual_exploder();
    }
}

deactivate_exploder( num )
{
    num = int( num );

    if ( isdefined( level.createfxexploders[num] ) )
    {
        for ( i = 0; i < level.createfxexploders[num].size; i++ )
        {
            ent = level.createfxexploders[num][i];

            if ( isdefined( ent.soundent ) )
            {
                deletefakeent( 0, ent.soundent );
                ent.soundent = undefined;
            }

            if ( isdefined( ent.loopfx ) )
            {
                for ( j = 0; j < ent.loopfx.size; j++ )
                {
                    if ( isdefined( ent.loopfx[j] ) )
                        stopfx( j, ent.loopfx[j] );
                }

                ent.loopfx = [];
            }
        }
    }
}

exploder( num )
{
    activate_exploder( num );
}

activate_individual_exploder()
{
    if ( !isdefined( self.v["angles"] ) )
    {
        self.v["angles"] = ( 0, 0, 0 );
        self set_forward_and_up_vectors();
    }

    if ( isdefined( self.v["firefx"] ) )
        self thread fire_effect();

    if ( isdefined( self.v["fxid"] ) && self.v["fxid"] != "No FX" )
        self thread cannon_effect();

    if ( isdefined( self.v["earthquake"] ) )
        self thread exploder_earthquake();
}

fire_effect()
{
    forward = self.v["forward"];
    up = self.v["up"];
    firefxsound = self.v["firefxsound"];
    origin = self.v["origin"];
    firefx = self.v["firefx"];
    ender = self.v["ender"];

    if ( !isdefined( ender ) )
        ender = "createfx_effectStopper";

    timeout = self.v["firefxtimeout"];
    firefxdelay = 0.5;

    if ( isdefined( self.v["firefxdelay"] ) )
        firefxdelay = self.v["firefxdelay"];

    self exploder_delay();

    if ( isdefined( firefxsound ) )
        level thread clientscripts\mp\_utility::loop_fx_sound( firefxsound, origin, ender, timeout );

    if ( level.createfx_disable_fx )
        return;

    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
        playfx( i, level._effect[firefx], self.v["origin"], forward, up );
}

cannon_effect()
{
    if ( level.createfx_disable_fx )
        return;

    if ( isdefined( self.v["repeat"] ) )
    {
        for ( i = 0; i < self.v["repeat"]; i++ )
        {
            players = getlocalplayers();

            for ( player = 0; player < players.size; player++ )
                playfx( player, level._effect[self.v["fxid"]], self.v["origin"], self.v["forward"], self.v["up"] );

            self exploder_delay();
        }

        return;
    }

    self exploder_delay();
    players = getlocalplayers();

    if ( isdefined( self.loopfx ) )
    {
        for ( i = 0; i < self.loopfx.size; i++ )
            stopfx( i, self.loopfx[i] );

        self.loopfx = [];
    }

    if ( !isdefined( self.loopfx ) )
        self.loopfx = [];

    if ( !isdefined( level._effect[self.v["fxid"]] ) )
    {
/#
        assertmsg( "*** Client : Effect " + self.v["fxid"] + " not precached in level_fx.csc." );
#/
        return;
    }

    for ( i = 0; i < players.size; i++ )
    {
        if ( isdefined( self.v["fxid"] ) )
            self.loopfx[i] = playfx( i, level._effect[self.v["fxid"]], self.v["origin"], self.v["forward"], self.v["up"] );
    }

    self exploder_playsound();
}

exploder_delay()
{
    if ( !isdefined( self.v["delay"] ) )
        self.v["delay"] = 0;

    min_delay = self.v["delay"];
    max_delay = self.v["delay"] + 0.001;

    if ( isdefined( self.v["delay_min"] ) )
        min_delay = self.v["delay_min"];

    if ( isdefined( self.v["delay_max"] ) )
        max_delay = self.v["delay_max"];

    if ( min_delay > 0 )
        waitrealtime( randomfloatrange( min_delay, max_delay ) );
}

exploder_earthquake()
{
    self exploder_delay();
    eq = level.earthquake[self.v["earthquake"]];

    if ( isdefined( eq ) )
        getlocalplayers()[0] earthquake( eq["magnitude"], eq["duration"], self.v["origin"], eq["radius"] );
}

exploder_playsound()
{
    if ( !isdefined( self.v["soundalias"] ) || self.v["soundalias"] == "nil" )
        return;

    play_sound_in_space( 0, self.v["soundalias"], self.v["origin"] );
}
